<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>간편 입찰 전략 계산기</title>
    <style>
        :root {
            color-scheme: light;
            --bg-color: #f6f8fc;
            --text-color: #1f2933;
            --subtle-text: #64748b;
            --card-bg: #ffffff;
            --primary: #2563eb;
            --primary-dark: #1d4ed8;
            --border: #e2e8f0;
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: 'Pretendard', 'Segoe UI', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg-color);
            color: var(--text-color);
            line-height: 1.6;
        }

        .app {
            max-width: 760px;
            margin: 0 auto;
            padding: 32px 16px 48px;
        }

        .app-header {
            text-align: center;
            margin-bottom: 28px;
        }

        .app-header h1 {
            font-size: 26px;
            margin: 0 0 10px;
            font-weight: 700;
            color: #0f172a;
        }

        .app-header p {
            margin: 0;
            color: var(--subtle-text);
            font-size: 15px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 24px;
            box-shadow: 0 12px 32px rgba(15, 23, 42, 0.08);
        }

        .input-card {
            margin-bottom: 20px;
        }

        .field {
            display: flex;
            flex-direction: column;
            gap: 6px;
            margin-bottom: 16px;
        }

        .field label {
            font-size: 14px;
            font-weight: 600;
            color: #334155;
        }

        .field input,
        .field textarea,
        .field select {
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 12px 14px;
            font-size: 15px;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
        }

        .field textarea {
            resize: vertical;
            min-height: 96px;
        }

        .field input:focus,
        .field textarea:focus,
        .field select:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.16);
            outline: none;
        }

        .field-group {
            display: grid;
            gap: 12px;
            margin-bottom: 16px;
        }

        .field .field-hint {
            color: var(--subtle-text);
            font-size: 13px;
        }

        .action-row {
            display: flex;
            gap: 12px;
            margin-top: 8px;
        }

        .btn {
            flex: 1;
            border: none;
            border-radius: 12px;
            padding: 13px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.15s ease, box-shadow 0.15s ease, background 0.2s ease;
        }

        .btn-primary {
            background: var(--primary);
            color: #ffffff;
            box-shadow: 0 10px 24px rgba(37, 99, 235, 0.28);
        }

        .btn-primary:hover {
            background: var(--primary-dark);
            transform: translateY(-1px);
        }

        .btn-secondary {
            background: #f1f5f9;
            color: #1f2937;
        }

        .btn-secondary:hover {
            background: #e2e8f0;
        }

        .loading-card {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 16px;
            min-height: 170px;
            text-align: center;
            color: var(--subtle-text);
            font-size: 14px;
        }

        .spinner {
            width: 38px;
            height: 38px;
            border-radius: 50%;
            border: 4px solid #dbeafe;
            border-top-color: var(--primary);
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .result-card {
            display: flex;
            flex-direction: column;
            gap: 24px;
        }

        #resultSummary {
            font-size: 15px;
            color: #1f2937;
            display: grid;
            gap: 8px;
        }

        #resultSummary strong {
            color: #0f172a;
        }

        #resultSummary .hint {
            color: var(--subtle-text);
            font-size: 14px;
        }

        #winRateChartSummary {
            white-space: pre-line;
        }

        .result-grid {
            display: grid;
            gap: 16px;
            grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
        }

        .result-box {
            background: #f8fafc;
            border-radius: 14px;
            padding: 18px;
            border: 1px solid var(--border);
        }

        .result-box h3 {
            margin: 0 0 10px;
            font-size: 15px;
            color: #1f2937;
        }

        .result-box.chart-box {
            grid-column: span 2;
        }

        .chart-container {
            position: relative;
            width: 100%;
            height: 220px;
            margin-top: 4px;
        }

        .chart-canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        .chart-summary {
            margin-top: 12px;
            font-size: 13px;
            color: #475569;
            line-height: 1.5;
        }

        .result-box ul {
            list-style: none;
            padding: 0;
            margin: 0;
            display: grid;
            gap: 8px;
            font-size: 14px;
            color: #4b5563;
        }

        .result-box li strong {
            color: #111827;
        }

        .probability-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
            font-size: 14px;
            color: #475569;
        }

        .probability-row:last-child {
            margin-bottom: 0;
        }

        .probability-label {
            width: 70px;
            font-weight: 600;
            color: #111827;
        }

        .probability-bar {
            position: relative;
            flex: 1;
            height: 8px;
            background: #e2e8f0;
            border-radius: 999px;
            overflow: hidden;
        }

        .probability-fill {
            position: absolute;
            inset: 0;
            width: 0;
            background: linear-gradient(90deg, #2563eb, #3b82f6);
        }

        .probability-value {
            width: 58px;
            text-align: right;
            font-variant-numeric: tabular-nums;
            color: #1f2937;
        }

        .note-card {
            background: #f1f5f9;
            border-radius: 14px;
            padding: 18px;
            border: 1px solid var(--border);
            font-size: 14px;
            color: #475569;
        }

        .note-card h3 {
            margin: 0 0 6px;
            font-size: 15px;
            color: #1f2937;
        }

        .app-footer {
            margin-top: 20px;
            text-align: center;
            font-size: 12px;
            color: #94a3b8;
        }

        [hidden] {
            display: none !important;
        }

        @media (max-width: 640px) {
            .action-row {
                flex-direction: column;
            }

            .btn {
                width: 100%;
            }

            .app {
                padding: 24px 14px 40px;
            }
        }
    </style>
</head>
<body>
    <div class="app">
        <header class="app-header">
            <h1>간편 입찰 전략 계산기</h1>
            <p>핵심 수치만 입력하면 가장 유리한 투찰 구간을 바로 확인할 수 있습니다.</p>
        </header>

        <form id="simulationForm" class="card input-card">
            <div class="field">
                <label for="openPrice">공개가격 (억원)</label>
                <input type="number" id="openPrice" name="openPrice" min="1" step="0.1" value="100">
            </div>
            <div class="field">
                <label for="companyCount">참여 업체 수</label>
                <input type="number" id="companyCount" name="companyCount" min="1" step="1" value="8">
                <small class="field-hint">우리 회사를 포함한 전체 참여 업체 수를 입력하세요.</small>
            </div>
            <div class="field">
                <label for="distributionType">경쟁 업체 분포</label>
                <select id="distributionType" name="distributionType">
                    <option value="uniform">균등분포 (동일 확률)</option>
                    <option value="triangular">삼각분포 (중앙값 쏠림)</option>
                    <option value="truncnormal">절단정규분포 (평균/표준편차)</option>
                    <option value="mixture" selected>혼합분포 (균등+삼각+절단정규)</option>
                </select>
                <small class="field-hint">경쟁 업체 제시가격이 따른다고 가정하는 분포를 선택하세요.</small>
            </div>
            <div class="field-group" aria-live="polite">
                <div class="field">
                    <label for="baseRate">기준 투찰률 (소수)</label>
                    <input type="number" id="baseRate" name="baseRate" min="0.3" max="1.2" step="0.00001" value="0.79995">
                    <small class="field-hint">공개가격에 곱해 기준가격을 계산할 때 사용하는 비율입니다.</small>
                </div>
                <div class="field">
                    <label for="rangeRatio">임계값 범위 비율 (소수)</label>
                    <input type="number" id="rangeRatio" name="rangeRatio" min="0.001" max="0.5" step="0.0005" value="0.02">
                    <small class="field-hint">기준가격 대비 상·하단 임계값 범위를 결정하는 ±비율입니다.</small>
                </div>
                <div class="field">
                    <label for="positiveSampleSize">표본 크기 (+임계값 범위)</label>
                    <input type="number" id="positiveSampleSize" name="positiveSampleSize" min="0" max="200" step="1" value="8">
                    <small class="field-hint">임계값 상단(+) 구간에서 사용하는 표본 개수입니다.</small>
                </div>
                <div class="field">
                    <label for="negativeSampleSize">표본 크기 (-임계값 범위)</label>
                    <input type="number" id="negativeSampleSize" name="negativeSampleSize" min="0" max="200" step="1" value="7">
                    <small class="field-hint">임계값 하단(-) 구간에서 사용하는 표본 개수입니다.</small>
                </div>
                <div class="field">
                    <label for="pickSize">추출 개수</label>
                    <input type="number" id="pickSize" name="pickSize" min="1" max="200" step="1" value="4">
                    <small class="field-hint">표본 중 평균을 계산할 때 선택하는 항목 수입니다.</small>
                </div>
            </div>
            <div class="action-row">
                <button type="submit" class="btn btn-primary">분석 실행</button>
                <button type="button" id="resetButton" class="btn btn-secondary">초기화</button>
            </div>
        </form>

        <div id="loadingIndicator" class="card loading-card" hidden role="status" aria-live="polite" aria-atomic="true">
            <div class="spinner" aria-hidden="true"></div>
            <p>확률 분포를 계산하는 중입니다...</p>
            <small>잠시만 기다려 주세요.</small>
        </div>

        <section id="resultSection" class="card result-card" hidden aria-live="polite" aria-busy="false">
            <div id="resultSummary"></div>

            <div class="result-grid">
                <div class="result-box">
                    <h3>핵심 지표</h3>
                    <div id="strategyNotes"></div>
                </div>
                <div class="result-box">
                    <h3>낙찰 확률 상위 구간</h3>
                    <div id="probabilityList"></div>
                </div>
                <div class="result-box chart-box">
                    <h3>가격별 낙찰 확률</h3>
                    <div class="chart-container">
                        <canvas id="winRateChart" class="chart-canvas" width="600" height="220" aria-label="가격별 낙찰 확률 곡선"></canvas>
                    </div>
                    <p id="winRateChartSummary" class="chart-summary"></p>
                </div>
            </div>

            <div class="note-card">
                <h3>시장 해석</h3>
                <p id="marketInsight"></p>
            </div>
        </section>

        <footer class="app-footer">
            ※ 본 계산기는 참고용 이론적 확률 계산 결과를 제공합니다. 실제 투찰 전 추가 검토가 필요합니다.
        </footer>
    </div>

    <script>
        (() => {
            const DEFAULTS = {
                openPrice: 100,
                companyCount: 8,
                distributionType: 'mixture',
                distributionParams: {
                    uniform: { minRate: 78.50, maxRate: 81.50 },
                    triangular: { minRate: 78.50, modeRate: 80.00, maxRate: 81.50 },
                    truncnormal: { meanRate: 80.00, stdRate: 0.45 },
                    mixture: {
                        uniformWeight: 5.0,          // 극단적 랜덤 전략 거의 없음
                        triangularWeight: 60.0,      // 대다수는 중앙값 쏠림
                        truncnormalWeight: 35.0,     // 일부는 평균±편차에 분포
                        uniformMinRate: 77.50,
                        uniformMaxRate: 82.50,
                        triMinRate: 78.50,
                        triModeRate: 80.00,
                        triMaxRate: 81.20,
                        truncMeanRate: 80.00,
                        truncStdRate: 0.35           // 표준편차를 줄여서 더 중앙 집중
                    }
                },
                calculation: {
                    baseRate: 0.79995,
                    rangeRatio: 0.02,
                    positiveSampleSize: 8,
                    negativeSampleSize: 7,
                    pickSize: 4
                }
            };

            const CANDIDATE_GRID_POINTS = 121;
            const RATE_MIN = 50;
            const RATE_MAX = 120;
            const RATE_STD_MIN = 0.01;
            const RATE_STD_MAX = 10;

            const form = document.getElementById('simulationForm');
            const loadingIndicator = document.getElementById('loadingIndicator');
            const resultSection = document.getElementById('resultSection');
            const resultSummary = document.getElementById('resultSummary');
            const strategyNotes = document.getElementById('strategyNotes');
            const probabilityList = document.getElementById('probabilityList');
            const winRateChartCanvas = document.getElementById('winRateChart');
            const winRateChartSummary = document.getElementById('winRateChartSummary');
            const marketInsight = document.getElementById('marketInsight');
            const resetButton = document.getElementById('resetButton');
            const companyCountInput = document.getElementById('companyCount');
            const distributionTypeSelect = document.getElementById('distributionType');
            const baseRateInput = document.getElementById('baseRate');
            const rangeRatioInput = document.getElementById('rangeRatio');
            const positiveSampleSizeInput = document.getElementById('positiveSampleSize');
            const negativeSampleSizeInput = document.getElementById('negativeSampleSize');
            const pickSizeInput = document.getElementById('pickSize');

            let latestChartState = null;

            window.addEventListener('resize', () => {
                if (!winRateChartCanvas || !latestChartState) {
                    return;
                }
                renderWinRateChart(winRateChartCanvas, latestChartState.results, latestChartState.params);
            });

            form.addEventListener('submit', event => {
                event.preventDefault();
                runAnalysis();
            });

            distributionTypeSelect.addEventListener('change', () => {
                runAnalysis();
            });

            resetButton.addEventListener('click', () => {
                form.reset();
                runAnalysis();
            });

            runAnalysis();

            function runAnalysis() {
                showLoading();

                window.setTimeout(() => {
                    const params = collectFormData();
                    const results = analyzeBids(params);
                    hideLoading();
                    displayResults(params, results);
                }, 30);
            }

            function showLoading() {
                loadingIndicator.hidden = false;
                setResultBusyState(true);
                resultSection.hidden = true;
            }

            function hideLoading() {
                loadingIndicator.hidden = true;
            }

            function setResultBusyState(isBusy) {
                if (!resultSection) {
                    return;
                }
                resultSection.setAttribute('aria-busy', isBusy ? 'true' : 'false');
            }

            function collectFormData() {
                const openPrice = sanitizeNumber(document.getElementById('openPrice').value, DEFAULTS.openPrice, 1, 10000);
                const companyCount = sanitizeInteger(companyCountInput.value, DEFAULTS.companyCount, 1, 60);
                let distributionType = distributionTypeSelect.value || DEFAULTS.distributionType;
                if (!Object.prototype.hasOwnProperty.call(DEFAULTS.distributionParams, distributionType)) {
                    distributionType = DEFAULTS.distributionType;
                }
                const distributionParams = { ...(DEFAULTS.distributionParams[distributionType] ?? {}) };
                const baseRate = sanitizeNumber(baseRateInput.value, DEFAULTS.calculation.baseRate, 0.3, 1.2);
                const rangeRatio = sanitizeNumber(rangeRatioInput.value, DEFAULTS.calculation.rangeRatio, 0.001, 0.5);
                let positiveSampleSize = sanitizeInteger(
                    positiveSampleSizeInput.value,
                    DEFAULTS.calculation.positiveSampleSize,
                    0,
                    200
                );
                let negativeSampleSize = sanitizeInteger(
                    negativeSampleSizeInput.value,
                    DEFAULTS.calculation.negativeSampleSize,
                    0,
                    200
                );
                let sampleSize = positiveSampleSize + negativeSampleSize;
                if (!Number.isFinite(sampleSize) || sampleSize < 1) {
                    positiveSampleSize = Math.max(0, DEFAULTS.calculation.positiveSampleSize);
                    negativeSampleSize = Math.max(0, DEFAULTS.calculation.negativeSampleSize);
                    sampleSize = Math.max(1, positiveSampleSize + negativeSampleSize);
                }
                const pickSize = sanitizeInteger(
                    pickSizeInput.value,
                    DEFAULTS.calculation.pickSize,
                    1,
                    Math.max(sampleSize, 1)
                );
                return {
                    openPrice,
                    companyCount,
                    distributionType,
                    distributionParams,
                    baseRate,
                    rangeRatio,
                    positiveSampleSize,
                    negativeSampleSize,
                    sampleSize,
                    pickSize
                };
            }

            function sanitizeNumber(value, fallback, min = -Infinity, max = Infinity) {
                const parsed = Number.parseFloat(value);
                if (!Number.isFinite(parsed)) {
                    return fallback;
                }
                const lower = Number.isFinite(min) ? min : -Infinity;
                const upper = Number.isFinite(max) ? max : Infinity;
                return Math.min(upper, Math.max(lower, parsed));
            }

            function sanitizeInteger(value, fallback, min = -Infinity, max = Infinity) {
                const parsed = Number.parseInt(value, 10);
                if (!Number.isFinite(parsed)) {
                    return fallback;
                }
                const lower = Number.isFinite(min) ? min : -Infinity;
                const upper = Number.isFinite(max) ? max : Infinity;
                const clamped = Math.min(upper, Math.max(lower, parsed));
                return Math.trunc(clamped);
            }

            function analyzeBids(params) {
                const baseRate = Number.isFinite(params.baseRate) ? params.baseRate : DEFAULTS.calculation.baseRate;
                const rangeRatio = Number.isFinite(params.rangeRatio) ? params.rangeRatio : DEFAULTS.calculation.rangeRatio;
                const pickSize = Number.isFinite(params.pickSize) ? params.pickSize : DEFAULTS.calculation.pickSize;
                const basePrice = params.openPrice * baseRate;
                const low = basePrice * (1 - rangeRatio);
                const high = basePrice * (1 + rangeRatio);
                const gridHigh = Math.max(high, params.openPrice);
                const mean = (low + high) / 2;
                const stdDev = (high - low) / Math.sqrt(12 * pickSize);

                const distribution = buildCompetitorDistributionFromSelection(params, low, high);
                const otherCompanyCount = Math.max(0, (params.companyCount ?? DEFAULTS.companyCount) - 1);
                const totalCompanyCount = otherCompanyCount + 1;

                const integrationGrid = createIntegrationGrid(low, high, 4096);
                const averagePdfValues = integrationGrid.map(value =>
                    averagePdf(value, low, high, pickSize, distribution, params.sampleSize)
                );
                const distributionCdfValues = integrationGrid.map(value =>
                    averageCdf(value, low, high, pickSize, distribution, params.sampleSize)
                );

                const results = [];
                let bestIndex = -1;
                let maxProbability = -Infinity;

                for (let idx = 0; idx < CANDIDATE_GRID_POINTS; idx++) {
                    const ratio = CANDIDATE_GRID_POINTS > 1 ? idx / (CANDIDATE_GRID_POINTS - 1) : 0;
                    const price = low + (gridHigh - low) * ratio;
                    const rate = (price / params.openPrice) * 100;
                    const probability = computeWinProbability(
                        price,
                        low,
                        high,
                        otherCompanyCount,
                        distribution,
                        integrationGrid,
                        averagePdfValues,
                        distributionCdfValues,
                        pickSize
                    );
                    const thresholdUpper = Math.min(price, high);
                    const thresholdShare = averageCdf(thresholdUpper, low, high, pickSize, distribution);

                    const competitorShareBelow = clamp01(distribution.cdf(price));

                    const entry = {
                        rate,
                        price,
                        probability,
                        thresholdUpper,
                        thresholdShare,
                        competitorShareBelow
                    };

                    results.push(entry);

                    if (probability > maxProbability) {
                        maxProbability = probability;
                        bestIndex = idx;
                    }
                }

                const maxPrice = results.reduce((acc, item) => Math.max(acc, item.price), low);
                const coverage = averageCdf(Math.min(maxPrice, high), low, high, pickSize, distribution);

                const leftoverProbability = Math.max(0, 1 - coverage);

                const topIndices = results
                    .map((_, idx) => idx)
                    .sort((a, b) => results[b].probability - results[a].probability)
                    .slice(0, Math.min(5, results.length));

                return {
                    basePrice,
                    low,
                    high,
                    mean,
                    stdDev,
                    bids: results,
                    bestIndex,
                    topIndices,
                    leftoverProbability,
                    otherCompanyCount,
                    totalCompanyCount,
                    distribution,
                    maxPrice
                };
            }

            function createIntegrationGrid(low, high, steps = 4096) {
                const pointCount = Math.max(2, Math.trunc(steps));
                const result = new Array(pointCount);
                const step = (high - low) / (pointCount - 1);
                for (let idx = 0; idx < pointCount; idx++) {
                    result[idx] = low + step * idx;
                }
                return result;
            }

            function computeWinProbability(price, low, high, otherCompanyCount, distribution, grid, averagePdfValues, distributionCdfValues, pickSize) {
                if (price <= low) {
                    return 0;
                }

                // 경쟁사가 없는 경우 → 임계값이 price 이하에서 형성될 확률
                if (otherCompanyCount <= 0) {
                    return averageCdf(price, low, high, pickSize, distribution);
                }

                // 경쟁사가 있는 경우 → 적분 기반 계산 유지
                const upper = price;
                if (upper <= low) return 0;

                const gp = clamp01(distribution.cdf(price));
                const exponent = otherCompanyCount;

                const integrand = (pdfValue, cdfValue) => {
                    if (pdfValue <= 0) return 0;
                    const base = clamp01(cdfValue + 1 - gp);
                    return pdfValue * Math.pow(base, exponent);
                };

                let integral = 0;
                let previousA = grid[0];
                let previousIntegrand = integrand(averagePdfValues[0], distributionCdfValues[0]);

                for (let idx = 1; idx < grid.length; idx++) {
                    const currentA = grid[idx];
                    const currentIntegrand = integrand(averagePdfValues[idx], distributionCdfValues[idx]);

                    if (currentA >= upper) {
                        const finalPdf = averagePdf(upper, low, high, pickSize, distribution);
                        const finalCdf = distribution.cdf(upper);
                        const finalIntegrand = integrand(finalPdf, finalCdf);
                        integral += 0.5 * (upper - previousA) * (previousIntegrand + finalIntegrand);
                        break;
                    } else {
                        integral += 0.5 * (currentA - previousA) * (previousIntegrand + currentIntegrand);
                        previousA = currentA;
                        previousIntegrand = currentIntegrand;
                    }
                }

                return clamp01(integral);
            }

            function averagePdf(value, low, high, pickSize, distribution, sampleSize) {
                if (value <= low || sampleSize <= 0) return 0;

                // Irwin–Hall 분포 (표본합) → 표본평균 분포로 변환
                const range = high - low;
                const z = (value - low) / range * sampleSize;

                // Irwin–Hall PDF 계산
                let pdf = 0;
                for (let k = 0; k <= Math.floor(z); k++) {
                    const sign = (k % 2 === 0 ? 1 : -1);
                    pdf += sign * combination(sampleSize, k) * Math.pow(z - k, sampleSize - 1);
                }
                pdf /= factorial(sampleSize - 1);

                // 표본평균 분포이므로 스케일 조정
                return pdf * (sampleSize / range);
            }

            function averageCdf(value, low, high, pickSize, distribution, sampleSize) {
                if (value <= low || sampleSize <= 0) return 0;

                const range = high - low;
                const z = (value - low) / range * sampleSize;

                // Irwin–Hall CDF 계산
                let cdf = 0;
                for (let k = 0; k <= Math.floor(z); k++) {
                    const sign = (k % 2 === 0 ? 1 : -1);
                    cdf += sign * combination(sampleSize, k) * Math.pow(z - k, sampleSize);
                }
                cdf /= factorial(sampleSize);

                return clamp01(cdf);
            }

            function irwinHallCdf(z, n) {
                if (z <= 0) {
                    return 0;
                }
                if (z >= n) {
                    return 1;
                }

                const upper = Math.floor(z);
                let sum = 0;

                for (let k = 0; k <= upper; k++) {
                    const sign = k % 2 === 0 ? 1 : -1;
                    sum += sign * combination(n, k) * Math.pow(z - k, n);
                }

                return sum / factorial(n);
            }

            function irwinHallPdf(z, n) {
                if (z <= 0 || z >= n) {
                    return 0;
                }

                const upper = Math.floor(z);
                let sum = 0;

                for (let k = 0; k <= upper; k++) {
                    const sign = k % 2 === 0 ? 1 : -1;
                    sum += sign * combination(n, k) * Math.pow(z - k, n - 1);
                }

                return sum / factorial(n - 1);
            }

            function combination(n, k) {
                if (k < 0 || k > n) {
                    return 0;
                }
                if (k === 0 || k === n) {
                    return 1;
                }
                let result = 1;
                for (let i = 1; i <= k; i++) {
                    result *= (n - (k - i));
                    result /= i;
                }
                return result;
            }

            function factorial(n) {
                let result = 1;
                for (let i = 2; i <= n; i++) {
                    result *= i;
                }
                return result;
            }

            function buildCompetitorDistributionFromSelection(params, low, high) {
                const type = params.distributionType || DEFAULTS.distributionType;
                const openPrice = params.openPrice;
                const settings = params.distributionParams ?? {};
                const defaults = DEFAULTS.distributionParams;
                const toPrice = rate => openPrice * (rate / 100);
                const toRate = price => (price / openPrice) * 100;

                const createUniformFromRates = () => {
                    const uniformDefaults = defaults.uniform;
                    let minRate = sanitizeNumber(settings.minRate, uniformDefaults.minRate, RATE_MIN, RATE_MAX);
                    let maxRate = sanitizeNumber(settings.maxRate, uniformDefaults.maxRate, RATE_MIN, RATE_MAX);
                    if (!Number.isFinite(minRate)) minRate = uniformDefaults.minRate;
                    if (!Number.isFinite(maxRate)) maxRate = uniformDefaults.maxRate;
                    if (minRate > maxRate) {
                        [minRate, maxRate] = [maxRate, minRate];
                    }
                    if (Math.abs(maxRate - minRate) < 1e-6) {
                        maxRate = minRate + 0.1;
                    }
                    const distribution = createUniformDistribution(toPrice(minRate), toPrice(maxRate));
                    const description = `하한 ${minRate.toFixed(2)}% ~ 상한 ${maxRate.toFixed(2)}%`;
                    return {
                        ...enrichDistribution(distribution, '균등 분포', openPrice, description),
                        rateMin: Math.min(minRate, maxRate),
                        rateMax: Math.max(minRate, maxRate)
                    };
                };

                const createTriangularFromRates = () => {
                    const triDefaults = defaults.triangular;
                    let minRate = sanitizeNumber(settings.minRate, triDefaults.minRate, RATE_MIN, RATE_MAX);
                    let modeRate = sanitizeNumber(settings.modeRate, triDefaults.modeRate, RATE_MIN, RATE_MAX);
                    let maxRate = sanitizeNumber(settings.maxRate, triDefaults.maxRate, RATE_MIN, RATE_MAX);
                    if (!Number.isFinite(minRate)) minRate = triDefaults.minRate;
                    if (!Number.isFinite(modeRate)) modeRate = triDefaults.modeRate;
                    if (!Number.isFinite(maxRate)) maxRate = triDefaults.maxRate;
                    if (minRate > maxRate) {
                        [minRate, maxRate] = [maxRate, minRate];
                    }
                    if (Math.abs(maxRate - minRate) < 1e-6) {
                        maxRate = minRate + 0.1;
                    }
                    modeRate = clamp(modeRate, minRate, maxRate);
                    const distribution = createTriangularDistribution(toPrice(minRate), toPrice(modeRate), toPrice(maxRate));
                    const description = `최솟값 ${minRate.toFixed(2)}% / 최빈값 ${modeRate.toFixed(2)}% / 최댓값 ${maxRate.toFixed(2)}%`;
                    return {
                        ...enrichDistribution(distribution, '삼각 분포', openPrice, description),
                        rateMin: minRate,
                        rateMode: modeRate,
                        rateMax: maxRate
                    };
                };

                const createTruncNormalFromRates = () => {
                    const truncDefaults = defaults.truncnormal;
                    let meanRate = sanitizeNumber(settings.meanRate, truncDefaults.meanRate, RATE_MIN, RATE_MAX);
                    let stdRate = sanitizeNumber(settings.stdRate, truncDefaults.stdRate, RATE_STD_MIN, RATE_STD_MAX);
                    if (!Number.isFinite(meanRate)) meanRate = truncDefaults.meanRate;
                    if (!Number.isFinite(stdRate) || stdRate <= 0) stdRate = truncDefaults.stdRate;
                    const mu = toPrice(meanRate);
                    const sigma = Math.max(openPrice * (stdRate / 100), (high - low) / 200, Math.abs(mu) * 1e-6);
                    const distribution = buildTruncatedNormalDistribution(low, high, mu, sigma);
                    const description = `평균 ${meanRate.toFixed(2)}%, 표준편차 ${stdRate.toFixed(2)}%`;
                    return {
                        ...enrichDistribution(distribution, '절단 정규 분포', openPrice, description),
                        rateMean: meanRate,
                        rateStd: stdRate,
                        supportRateLow: toRate(low),
                        supportRateHigh: toRate(high)
                    };
                };

                const createMixtureFromRates = () => {
                    const mixDefaults = defaults.mixture ?? {};

                    let uniformWeight = sanitizeNumber(settings.uniformWeight, mixDefaults.uniformWeight, 0, 100);
                    let triangularWeight = sanitizeNumber(settings.triangularWeight, mixDefaults.triangularWeight, 0, 100);
                    let truncnormalWeight = sanitizeNumber(settings.truncnormalWeight, mixDefaults.truncnormalWeight, 0, 100);

                    if (!Number.isFinite(uniformWeight)) uniformWeight = Number.isFinite(mixDefaults.uniformWeight) ? mixDefaults.uniformWeight : 0;
                    if (!Number.isFinite(triangularWeight)) triangularWeight = Number.isFinite(mixDefaults.triangularWeight) ? mixDefaults.triangularWeight : 0;
                    if (!Number.isFinite(truncnormalWeight)) truncnormalWeight = Number.isFinite(mixDefaults.truncnormalWeight) ? mixDefaults.truncnormalWeight : 0;

                    const weights = {
                        uniform: Math.max(0, uniformWeight),
                        triangular: Math.max(0, triangularWeight),
                        truncnormal: Math.max(0, truncnormalWeight)
                    };

                    let totalWeight = weights.uniform + weights.triangular + weights.truncnormal;
                    if (totalWeight <= 1e-6) {
                        weights.uniform = Math.max(0, Number.isFinite(mixDefaults.uniformWeight) ? mixDefaults.uniformWeight : 1);
                        weights.triangular = Math.max(0, Number.isFinite(mixDefaults.triangularWeight) ? mixDefaults.triangularWeight : 0);
                        weights.truncnormal = Math.max(0, Number.isFinite(mixDefaults.truncnormalWeight) ? mixDefaults.truncnormalWeight : 0);
                        totalWeight = weights.uniform + weights.triangular + weights.truncnormal;
                    }
                    if (totalWeight <= 1e-6) {
                        weights.uniform = 1;
                        weights.triangular = 0;
                        weights.truncnormal = 0;
                        totalWeight = 1;
                    }

                    const normalizeWeight = value => (totalWeight > 0 ? value / totalWeight : 0);

                    let uniformMinRate = sanitizeNumber(settings.uniformMinRate, mixDefaults.uniformMinRate, RATE_MIN, RATE_MAX);
                    let uniformMaxRate = sanitizeNumber(settings.uniformMaxRate, mixDefaults.uniformMaxRate, RATE_MIN, RATE_MAX);
                    if (!Number.isFinite(uniformMinRate)) uniformMinRate = Number.isFinite(mixDefaults.uniformMinRate) ? mixDefaults.uniformMinRate : RATE_MIN;
                    if (!Number.isFinite(uniformMaxRate)) uniformMaxRate = Number.isFinite(mixDefaults.uniformMaxRate) ? mixDefaults.uniformMaxRate : RATE_MAX;
                    if (uniformMinRate > uniformMaxRate) {
                        [uniformMinRate, uniformMaxRate] = [uniformMaxRate, uniformMinRate];
                    }
                    if (Math.abs(uniformMaxRate - uniformMinRate) < 1e-6) {
                        uniformMaxRate = uniformMinRate + 0.1;
                    }
                    const uniformDistribution = createUniformDistribution(toPrice(uniformMinRate), toPrice(uniformMaxRate));
                    const uniformSummary = `하한 ${uniformMinRate.toFixed(2)}% ~ 상한 ${uniformMaxRate.toFixed(2)}%`;

                    let triMinRate = sanitizeNumber(settings.triMinRate, mixDefaults.triMinRate, RATE_MIN, RATE_MAX);
                    let triModeRate = sanitizeNumber(settings.triModeRate, mixDefaults.triModeRate, RATE_MIN, RATE_MAX);
                    let triMaxRate = sanitizeNumber(settings.triMaxRate, mixDefaults.triMaxRate, RATE_MIN, RATE_MAX);
                    if (!Number.isFinite(triMinRate)) triMinRate = Number.isFinite(mixDefaults.triMinRate) ? mixDefaults.triMinRate : RATE_MIN;
                    if (!Number.isFinite(triModeRate)) triModeRate = Number.isFinite(mixDefaults.triModeRate) ? mixDefaults.triModeRate : triMinRate;
                    if (!Number.isFinite(triMaxRate)) triMaxRate = Number.isFinite(mixDefaults.triMaxRate) ? mixDefaults.triMaxRate : RATE_MAX;
                    if (triMinRate > triMaxRate) {
                        [triMinRate, triMaxRate] = [triMaxRate, triMinRate];
                    }
                    if (Math.abs(triMaxRate - triMinRate) < 1e-6) {
                        triMaxRate = triMinRate + 0.1;
                    }
                    triModeRate = clamp(triModeRate, triMinRate, triMaxRate);
                    const triangularDistribution = createTriangularDistribution(toPrice(triMinRate), toPrice(triModeRate), toPrice(triMaxRate));
                    const triangularSummary = `최솟값 ${triMinRate.toFixed(2)}% / 최빈값 ${triModeRate.toFixed(2)}% / 최댓값 ${triMaxRate.toFixed(2)}%`;

                    let truncMeanRate = sanitizeNumber(settings.truncMeanRate, mixDefaults.truncMeanRate, RATE_MIN, RATE_MAX);
                    let truncStdRate = sanitizeNumber(settings.truncStdRate, mixDefaults.truncStdRate, RATE_STD_MIN, RATE_STD_MAX);
                    if (!Number.isFinite(truncMeanRate)) {
                        const fallbackMean = defaults.truncnormal?.meanRate;
                        truncMeanRate = Number.isFinite(fallbackMean) ? fallbackMean : (mixDefaults.truncMeanRate ?? RATE_MIN);
                    }
                    if (!Number.isFinite(truncStdRate) || truncStdRate <= 0) {
                        const fallbackStd = defaults.truncnormal?.stdRate;
                        truncStdRate = Number.isFinite(fallbackStd) ? fallbackStd : (mixDefaults.truncStdRate ?? 1);
                    }
                    const truncMu = toPrice(truncMeanRate);
                    const truncSigma = Math.max(openPrice * (truncStdRate / 100), (high - low) / 200, Math.abs(truncMu) * 1e-6);
                    const truncDistribution = buildTruncatedNormalDistribution(low, high, truncMu, truncSigma);
                    const truncSummary = `평균 ${truncMeanRate.toFixed(2)}%, 표준편차 ${truncStdRate.toFixed(2)}%`;

                    const components = [];
                    const uniformWeightNormalized = normalizeWeight(weights.uniform);
                    const triangularWeightNormalized = normalizeWeight(weights.triangular);
                    const truncWeightNormalized = normalizeWeight(weights.truncnormal);

                    if (uniformWeightNormalized > 0) {
                        components.push({
                            key: 'uniform',
                            label: '균등 분포',
                            weight: uniformWeightNormalized,
                            weightPercent: uniformWeightNormalized * 100,
                            summary: uniformSummary,
                            distribution: uniformDistribution
                        });
                    }
                    if (triangularWeightNormalized > 0) {
                        components.push({
                            key: 'triangular',
                            label: '삼각 분포',
                            weight: triangularWeightNormalized,
                            weightPercent: triangularWeightNormalized * 100,
                            summary: triangularSummary,
                            distribution: triangularDistribution
                        });
                    }
                    if (truncWeightNormalized > 0) {
                        components.push({
                            key: 'truncnormal',
                            label: '절단 정규 분포',
                            weight: truncWeightNormalized,
                            weightPercent: truncWeightNormalized * 100,
                            summary: truncSummary,
                            distribution: truncDistribution
                        });
                    }

                    const mixtureBase = createMixtureDistribution(components);
                    if (!mixtureBase) {
                        return createTruncNormalFromRates();
                    }

                    const weightSummary = components.length
                        ? components.map(component => `${component.label} ${component.weightPercent.toFixed(1)}%`).join(', ')
                        : '';
                    const detailSummary = components.length
                        ? components.map(component => {
                              const ratio = component.weightPercent.toFixed(1);
                              return component.summary ? `${component.label} ${ratio}% (${component.summary})` : `${component.label} ${ratio}%`;
                          }).join(' · ')
                        : '';
                    const description = weightSummary ? `가중치 기준: ${weightSummary}` : '가중치 정보를 확인할 수 없습니다.';

                    const enriched = enrichDistribution(mixtureBase, '혼합 분포', openPrice, description);
                    enriched.components = components.map(component => ({
                        key: component.key,
                        label: component.label,
                        weight: component.weight,
                        weightPercent: component.weightPercent,
                        summary: component.summary
                    }));
                    enriched.componentDetailSummary = detailSummary;
                    enriched.weightSummary = weightSummary;
                    enriched.isMixture = true;
                    return enriched;
                };

                switch (type) {
                    case 'uniform':
                        return createUniformFromRates();
                    case 'triangular':
                        return createTriangularFromRates();
                    case 'mixture':
                        return createMixtureFromRates();
                    case 'truncnormal':
                    default:
                        return createTruncNormalFromRates();
                }
            }

            function enrichDistribution(baseDistribution, typeLabel, openPrice, description) {
                const mu = Number.isFinite(baseDistribution.mu) ? baseDistribution.mu : 0;
                const sigma = Number.isFinite(baseDistribution.sigma) ? baseDistribution.sigma : 0;
                return {
                    ...baseDistribution,
                    type: typeLabel,
                    mu,
                    sigma,
                    rateMu: (mu / openPrice) * 100,
                    rateSigma: (sigma / openPrice) * 100,
                    description
                };
            }

            function buildTruncatedNormalDistribution(low, high, mu, sigma) {
                const range = high - low;
                let adjustedMu = clamp(mu, low + 0.01 * range, high - 0.01 * range);
                let adjustedSigma = Math.max(sigma, range / 40, 1e-6 * Math.abs(mu));
                let alpha;
                let beta;
                let denom;

                for (let attempt = 0; attempt < 6; attempt++) {
                    alpha = (low - adjustedMu) / adjustedSigma;
                    beta = (high - adjustedMu) / adjustedSigma;
                    denom = standardNormalCdf(beta) - standardNormalCdf(alpha);
                    if (denom > 1e-8) {
                        break;
                    }
                    adjustedSigma *= 1.5;
                }

                if (!Number.isFinite(denom) || denom <= 1e-8) {
                    return createUniformDistribution(low, high);
                }

                return {
                    type: '절단 정규',
                    mu: adjustedMu,
                    sigma: adjustedSigma,
                    pdf(value) {
                        if (value < low || value > high) {
                            return 0;
                        }
                        const z = (value - adjustedMu) / adjustedSigma;
                        return standardNormalPdf(z) / (adjustedSigma * denom);
                    },
                    cdf(value) {
                        if (value <= low) {
                            return 0;
                        }
                        if (value >= high) {
                            return 1;
                        }
                        const z = (value - adjustedMu) / adjustedSigma;
                        const numerator = standardNormalCdf(z) - standardNormalCdf(alpha);
                        return clamp01(numerator / denom);
                    }
                };
            }

            function createUniformDistribution(low, high) {
                const range = Math.max(high - low, 1e-9);
                const mu = (low + high) / 2;
                const sigma = range / Math.sqrt(12);
                return {
                    type: '균등',
                    mu,
                    sigma,
                    pdf(value) {
                        if (value < low || value > high) {
                            return 0;
                        }
                        return 1 / range;
                    },
                    cdf(value) {
                        if (value <= low) {
                            return 0;
                        }
                        if (value >= high) {
                            return 1;
                        }
                        return (value - low) / range;
                    }
                };
            }

            function createTriangularDistribution(min, mode, max) {
                const lower = Math.min(min, max);
                const upper = Math.max(min, max);

                if (!Number.isFinite(lower) || !Number.isFinite(upper)) {
                    return createUniformDistribution(min, max);
                }

                const range = upper - lower;
                if (range < 1e-6) {
                    return createUniformDistribution(lower, upper);
                }

                const epsilon = Math.max(range * 1e-3, 1e-6 * Math.max(1, Math.abs(upper)));
                let peak = Number.isFinite(mode) ? clamp(mode, lower + epsilon, upper - epsilon) : lower + range / 2;

                if (peak <= lower) {
                    peak = lower + epsilon;
                }
                if (peak >= upper) {
                    peak = upper - epsilon;
                }

                const leftWidth = peak - lower;
                const rightWidth = upper - peak;
                if (leftWidth <= 0 || rightWidth <= 0) {
                    return createUniformDistribution(lower, upper);
                }

                const mu = (lower + peak + upper) / 3;
                const variance = (lower * lower + peak * peak + upper * upper - lower * peak - lower * upper - peak * upper) / 18;
                const sigma = Math.sqrt(Math.max(variance, 0));

                return {
                    type: '삼각',
                    mu,
                    sigma,
                    pdf(value) {
                        if (value < lower || value > upper) {
                            return 0;
                        }
                        if (value <= peak) {
                            return (2 * (value - lower)) / ((upper - lower) * leftWidth);
                        }
                        return (2 * (upper - value)) / ((upper - lower) * rightWidth);
                    },
                    cdf(value) {
                        if (value <= lower) {
                            return 0;
                        }
                        if (value >= upper) {
                            return 1;
                        }
                        if (value <= peak) {
                            return Math.pow(value - lower, 2) / ((upper - lower) * leftWidth);
                        }
                        return 1 - Math.pow(upper - value, 2) / ((upper - lower) * rightWidth);
                    }
                };
            }

            function createMixtureDistribution(components) {
                if (!Array.isArray(components) || !components.length) {
                    return null;
                }

                const valid = components
                    .filter(component =>
                        component &&
                        typeof component.weight === 'number' &&
                        component.weight > 0 &&
                        component.distribution &&
                        typeof component.distribution.pdf === 'function' &&
                        typeof component.distribution.cdf === 'function'
                    );

                if (!valid.length) {
                    return null;
                }

                const totalWeight = valid.reduce((sum, component) => sum + component.weight, 0);
                if (totalWeight <= 0) {
                    return null;
                }

                const normalized = valid.map(component => ({
                    weight: component.weight / totalWeight,
                    distribution: component.distribution
                }));

                let mu = 0;
                let secondMoment = 0;
                normalized.forEach(component => {
                    const weight = component.weight;
                    const compMu = Number.isFinite(component.distribution.mu) ? component.distribution.mu : 0;
                    const compSigma = Number.isFinite(component.distribution.sigma) ? component.distribution.sigma : 0;
                    mu += weight * compMu;
                    secondMoment += weight * (compSigma * compSigma + compMu * compMu);
                });

                const variance = Math.max(0, secondMoment - mu * mu);
                const sigma = Math.sqrt(variance);

                return {
                    type: '혼합',
                    mu,
                    sigma,
                    pdf(value) {
                        return normalized.reduce((sum, component) => sum + component.weight * component.distribution.pdf(value), 0);
                    },
                    cdf(value) {
                        return normalized.reduce((sum, component) => sum + component.weight * component.distribution.cdf(value), 0);
                    }
                };
            }

            function standardNormalPdf(x) {
                return Math.exp(-0.5 * x * x) / Math.sqrt(2 * Math.PI);
            }

            function standardNormalCdf(x) {
                return 0.5 * (1 + erf(x / Math.SQRT2));
            }

            function erf(x) {
                const sign = x >= 0 ? 1 : -1;
                const absX = Math.abs(x);
                const t = 1 / (1 + 0.3275911 * absX);
                const a1 = 0.254829592;
                const a2 = -0.284496736;
                const a3 = 1.421413741;
                const a4 = -1.453152027;
                const a5 = 1.061405429;
                const poly = (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t;
                const expTerm = Math.exp(-absX * absX);
                return sign * (1 - poly * expTerm);
            }

            function clamp(value, min, max) {
                return Math.min(max, Math.max(min, value));
            }

            function clamp01(value) {
                return clamp(value, 0, 1);
            }

            function displayResults(params, results) {
                resultSection.hidden = false;
                setResultBusyState(false);

                if (!results.bids.length) {
                    resultSummary.innerHTML = `
                        <p>설정한 분포로 계산 가능한 투찰 구간이 없습니다. 입력값을 다시 확인해주세요.</p>
                    `;
                    strategyNotes.innerHTML = '';
                    probabilityList.innerHTML = '';
                    marketInsight.textContent = '경쟁 분포와 업체 수 설정을 조정한 뒤 다시 계산해주세요.';
                    clearWinRateChart('계산된 구간이 없어 그래프를 표시할 수 없습니다.');
                    return;
                }

                const bestBid = results.bestIndex >= 0 ? results.bids[results.bestIndex] : null;
                const probabilityPercent = bestBid ? bestBid.probability * 100 : 0;
                const expectedAmount = bestBid ? bestBid.price : 0;

                resultSummary.innerHTML = `
                    <p><strong>${bestBid.rate.toFixed(2)}%</strong> 투찰 시 낙찰 확률은 <strong>${probabilityPercent.toFixed(1)}%</strong>입니다.</p>
                    <p>해당 제시금액은 약 <strong>${formatAmount(expectedAmount)}</strong>입니다.</p>
                    <p class="hint">${buildStrategyHint(probabilityPercent)}</p>
                `;

                const rangeRatioPercent = Number.isFinite(params.rangeRatio)
                    ? params.rangeRatio * 100
                    : DEFAULTS.calculation.rangeRatio * 100;
                const rangePercent = rangeRatioPercent.toFixed(2);
                const lowRate = (results.low / params.openPrice) * 100;
                const highRate = (results.high / params.openPrice) * 100;
                const notes = [
                    `기준가격: <strong>${formatAmount(results.basePrice)}</strong>`,
                    `임계값 추정 범위 (±${rangePercent}%): <strong>${formatAmount(results.low)} ~ ${formatAmount(results.high)}</strong> (${lowRate.toFixed(2)}% ~ ${highRate.toFixed(2)}%)`,
                    `표본 평균 기대값: <strong>${formatAmount(results.mean)}</strong>`,
                    `표본 평균 분포 표준편차: <strong>${formatAmount(results.stdDev)}</strong>`,
                    `총 참여 업체 수: <strong>${results.totalCompanyCount}</strong>곳`,
                    `경쟁 업체 수(우리 제외): <strong>${results.otherCompanyCount}</strong>곳`
                ];

                if (results.distribution) {
                    const dist = results.distribution;
                    notes.push(`경쟁 분포 가정: <strong>${dist.type}</strong> (${dist.description})`);
                    notes.push(`분포 평균/표준편차: <strong>${formatAmount(dist.mu)}</strong> / <strong>${formatAmount(dist.sigma)}</strong> (투찰률 ${dist.rateMu.toFixed(2)}% / ${dist.rateSigma.toFixed(2)}%)`);
                    if (dist.isMixture) {
                        let componentNote = '';
                        if (Array.isArray(dist.components) && dist.components.length) {
                            componentNote = dist.components
                                .map(component => {
                                    const ratioSource = Number.isFinite(component.weightPercent)
                                        ? component.weightPercent
                                        : Number.isFinite(component.weight)
                                            ? component.weight * 100
                                            : 0;
                                    const ratioText = Number.isFinite(ratioSource) ? ratioSource.toFixed(1) : '0.0';
                                    const detail = component.summary ? ` (${component.summary})` : '';
                                    return `${component.label} ${ratioText}%${detail}`;
                                })
                                .join(' · ');
                        } else if (typeof dist.componentDetailSummary === 'string' && dist.componentDetailSummary) {
                            componentNote = dist.componentDetailSummary;
                        }
                        if (componentNote) {
                            notes.push(`혼합 구성: ${componentNote}`);
                        }
                    }
                }

                let positiveSampleSize = Number.isFinite(params.positiveSampleSize)
                    ? params.positiveSampleSize
                    : DEFAULTS.calculation.positiveSampleSize;
                let negativeSampleSize = Number.isFinite(params.negativeSampleSize)
                    ? params.negativeSampleSize
                    : DEFAULTS.calculation.negativeSampleSize;
                positiveSampleSize = Math.max(0, Math.trunc(positiveSampleSize));
                negativeSampleSize = Math.max(0, Math.trunc(negativeSampleSize));
                let sampleSize = positiveSampleSize + negativeSampleSize;
                if (!Number.isFinite(sampleSize) || sampleSize <= 0) {
                    positiveSampleSize = Math.max(0, DEFAULTS.calculation.positiveSampleSize);
                    negativeSampleSize = Math.max(0, DEFAULTS.calculation.negativeSampleSize);
                    sampleSize = Math.max(1, positiveSampleSize + negativeSampleSize);
                }
                const rawPickSize = Number.isFinite(params.pickSize)
                    ? params.pickSize
                    : DEFAULTS.calculation.pickSize;
                const pickSize = clamp(Math.trunc(rawPickSize), 1, Math.max(sampleSize, 1));
                const sampleBreakdown = `+${positiveSampleSize}개 · -${negativeSampleSize}개 (총 ${sampleSize}개)`;
                notes.push(`분석 방법: <strong>${sampleBreakdown} 중 ${pickSize}개 평균분포 + 타업체 연속분포 적분</strong>`);

                if (results.leftoverProbability > 1e-6) {
                    notes.push(`임계값이 최고 투찰금액을 초과해 낙찰자가 정해지지 않을 확률: <strong>${(results.leftoverProbability * 100).toFixed(1)}%</strong>`);
                } else {
                    notes.push('임계값 상단까지 전 구간을 포함해 계산되었습니다.');
                }

                strategyNotes.innerHTML = `<ul>${notes.map(note => `<li>${note}</li>`).join('')}</ul>`;

                probabilityList.innerHTML = results.topIndices.map(idx => {
                    const bid = results.bids[idx];
                    const probability = bid.probability * 100;
                    const fillWidth = Math.max(3, Math.min(100, probability));
                    const tooltip = [
                        `제시금액 ${formatAmount(bid.price)}`,
                        `임계값 커버 ${(bid.thresholdShare * 100).toFixed(1)}%`,
                        `타 업체 ≤ ${bid.rate.toFixed(2)}% 비중 ${(bid.competitorShareBelow * 100).toFixed(1)}%`
                    ].join(' | ');
                    return `
                        <div class="probability-row">
                            <div class="probability-label" title="${tooltip}">${bid.rate.toFixed(2)}%</div>
                            <div class="probability-bar">
                                <div class="probability-fill" style="width: ${fillWidth}%;"></div>
                            </div>
                            <div class="probability-value">${probability.toFixed(2)}%</div>
                        </div>
                    `;
                }).join('');

                updateWinRateChart(params, results);
                marketInsight.textContent = buildMarketInsight(params, results);
            }

            function updateWinRateChart(params, results) {
                if (!winRateChartCanvas) {
                    return;
                }

                if (!results || !results.bids || !results.bids.length) {
                    clearWinRateChart('그래프를 표시할 데이터가 없습니다.');
                    return;
                }

                latestChartState = { params, results };
                renderWinRateChart(winRateChartCanvas, results, params);

                if (winRateChartSummary) {
                    winRateChartSummary.textContent = buildWinRateChartSummary(params, results);
                }

                window.requestAnimationFrame(() => {
                    if (latestChartState && latestChartState.results === results) {
                        renderWinRateChart(winRateChartCanvas, results, params);
                    }
                });
            }

            function clearWinRateChart(message) {
                latestChartState = null;

                if (winRateChartSummary) {
                    winRateChartSummary.textContent = message || '그래프를 표시할 데이터가 없습니다.';
                }

                if (!winRateChartCanvas) {
                    return;
                }

                const parent = winRateChartCanvas.parentElement;
                const fallbackWidth = Number.parseFloat(winRateChartCanvas.dataset?.prevWidth) || 600;
                const fallbackHeight = Number.parseFloat(winRateChartCanvas.dataset?.prevHeight) || 220;
                const cssWidth = Math.max(320, Math.floor(winRateChartCanvas.clientWidth || (parent ? parent.clientWidth : 0) || fallbackWidth));
                const cssHeight = Math.max(200, Math.floor(winRateChartCanvas.clientHeight || (parent ? parent.clientHeight : 0) || fallbackHeight));
                const dpr = window.devicePixelRatio || 1;

                winRateChartCanvas.width = cssWidth * dpr;
                winRateChartCanvas.height = cssHeight * dpr;
                const ctx = winRateChartCanvas.getContext('2d');
                if (!ctx) {
                    return;
                }
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.clearRect(0, 0, winRateChartCanvas.width, winRateChartCanvas.height);
                winRateChartCanvas.dataset.prevWidth = String(cssWidth);
                winRateChartCanvas.dataset.prevHeight = String(cssHeight);
            }

            function renderWinRateChart(canvas, results, params) {
                const surface = prepareChartSurface(canvas);
                if (!surface) {
                    return;
                }

                const { ctx, width, height } = surface;
                const padding = { top: 18, right: 16, bottom: 36, left: 68 };
                const bids = Array.isArray(results.bids) ? results.bids : [];
                if (!bids.length) {
                    return;
                }

                const xValues = bids.map(bid => bid.price);
                const yValues = bids.map(bid => bid.probability);
                const minX = Math.min(...xValues);
                const maxX = Math.max(...xValues, params.openPrice);
                const maxProbability = Math.max(...yValues);
                const xRange = Math.max(maxX - minX, 1e-9);
                const yMax = computeNiceProbabilityCeiling(maxProbability);
                const chartWidth = Math.max(width - padding.left - padding.right, 10);
                const chartHeight = Math.max(height - padding.top - padding.bottom, 10);

                const scaleX = value => {
                    const ratio = (value - minX) / xRange;
                    return padding.left + clamp01(ratio) * chartWidth;
                };
                const scaleY = value => {
                    const bounded = value <= 0 ? 0 : Math.min(value, yMax);
                    const ratio = bounded / (yMax || 1);
                    return padding.top + (1 - ratio) * chartHeight;
                };

                ctx.fillStyle = '#f8fafc';
                ctx.fillRect(0, 0, width, height);

                const yTickCount = 4;
                ctx.font = '12px "Pretendard", "Segoe UI", sans-serif';
                ctx.fillStyle = '#64748b';
                ctx.strokeStyle = '#e2e8f0';
                ctx.lineWidth = 1;
                for (let idx = 0; idx <= yTickCount; idx++) {
                    const ratio = idx / yTickCount;
                    const value = yMax * ratio;
                    const y = padding.top + (1 - ratio) * chartHeight;
                    ctx.beginPath();
                    ctx.moveTo(padding.left, y);
                    ctx.lineTo(width - padding.right, y);
                    ctx.strokeStyle = 'rgba(148, 163, 184, 0.25)';
                    ctx.stroke();
                    ctx.textAlign = 'right';
                    ctx.textBaseline = 'middle';
                    ctx.fillStyle = '#64748b';
                    ctx.fillText(formatProbabilityLabel(value), padding.left - 10, y);
                }

                const xTickCount = 4;
                for (let idx = 0; idx <= xTickCount; idx++) {
                    const ratio = idx / xTickCount;
                    const value = minX + xRange * ratio;
                    const x = scaleX(value);
                    ctx.beginPath();
                    ctx.moveTo(x, padding.top);
                    ctx.lineTo(x, height - padding.bottom);
                    ctx.strokeStyle = 'rgba(148, 163, 184, 0.2)';
                    ctx.stroke();
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'top';
                    ctx.fillStyle = '#64748b';
                    ctx.fillText(formatPriceTick(value), x, height - padding.bottom + 8);
                }

                ctx.strokeStyle = '#94a3b8';
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.moveTo(padding.left, padding.top);
                ctx.lineTo(padding.left, height - padding.bottom);
                ctx.lineTo(width - padding.right, height - padding.bottom);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(scaleX(bids[0].price), height - padding.bottom);
                for (let idx = 0; idx < bids.length; idx++) {
                    const bid = bids[idx];
                    ctx.lineTo(scaleX(bid.price), scaleY(bid.probability));
                }
                // 마지막 확률이 0보다 크다면, 그 다음에 X축과 수직으로 닫기
                const lastBid = bids[bids.length - 1];
                if (lastBid.probability > 0) {
                    ctx.lineTo(scaleX(lastBid.price), height - padding.bottom);
                }
                ctx.lineTo(scaleX(bids[0].price), height - padding.bottom);
                ctx.closePath();

                const gradient = ctx.createLinearGradient(0, padding.top, 0, height - padding.bottom);
                gradient.addColorStop(0, 'rgba(37, 99, 235, 0.25)');
                gradient.addColorStop(1, 'rgba(37, 99, 235, 0.05)');
                ctx.fillStyle = gradient;
                ctx.fill();

                ctx.beginPath();
                for (let idx = 0; idx < bids.length; idx++) {
                    const bid = bids[idx];
                    const x = scaleX(bid.price);
                    const y = scaleY(bid.probability);
                    if (idx === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.strokeStyle = '#2563eb';
                ctx.lineWidth = 2;
                ctx.stroke();

                if (Number.isInteger(results.bestIndex) && results.bestIndex >= 0 && results.bestIndex < bids.length) {
                    const bestBid = bids[results.bestIndex];
                    const x = scaleX(bestBid.price);
                    const y = scaleY(bestBid.probability);
                    ctx.fillStyle = '#1d4ed8';
                    ctx.beginPath();
                    ctx.arc(x, y, 4, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.font = '12px "Pretendard", "Segoe UI", sans-serif';
                    ctx.fillStyle = '#1d4ed8';
                    ctx.textBaseline = 'bottom';
                    const alignRight = x > width - padding.right - 70;
                    ctx.textAlign = alignRight ? 'right' : 'left';
                    const labelX = alignRight ? x - 8 : x + 8;
                    const labelY = Math.max(padding.top + 12, y - 6);
                    ctx.fillText(`${bestBid.rate.toFixed(2)}%`, labelX, labelY);
                }
            }

            function prepareChartSurface(canvas) {
                if (!canvas) {
                    return null;
                }

                const parent = canvas.parentElement;
                const fallbackWidth = Number.parseFloat(canvas.dataset?.prevWidth) || 600;
                const fallbackHeight = Number.parseFloat(canvas.dataset?.prevHeight) || 220;
                const cssWidth = Math.max(320, Math.floor(canvas.clientWidth || (parent ? parent.clientWidth : 0) || fallbackWidth));
                const cssHeight = Math.max(200, Math.floor(canvas.clientHeight || (parent ? parent.clientHeight : 0) || fallbackHeight));
                const dpr = window.devicePixelRatio || 1;

                if (canvas.width !== cssWidth * dpr) {
                    canvas.width = cssWidth * dpr;
                }
                if (canvas.height !== cssHeight * dpr) {
                    canvas.height = cssHeight * dpr;
                }

                const ctx = canvas.getContext('2d');
                if (!ctx) {
                    return null;
                }

                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.scale(dpr, dpr);

                canvas.dataset.prevWidth = String(cssWidth);
                canvas.dataset.prevHeight = String(cssHeight);

                return { ctx, width: cssWidth, height: cssHeight, dpr };
            }

            function computeNiceProbabilityCeiling(probability) {
                const minCeiling = 0.05;
                if (!(probability > 0)) {
                    return minCeiling;
                }

                const paddedPercent = Math.min(100, Math.max(0.01, probability * 100 * 1.1));
                const exponent = Math.pow(10, Math.floor(Math.log10(paddedPercent)));
                const fraction = paddedPercent / exponent;
                let niceFraction;
                if (fraction <= 1) {
                    niceFraction = 1;
                } else if (fraction <= 2) {
                    niceFraction = 2;
                } else if (fraction <= 5) {
                    niceFraction = 5;
                } else {
                    niceFraction = 10;
                }
                const nicePercent = Math.min(100, niceFraction * exponent);
                return Math.max(minCeiling, nicePercent / 100);
            }

            function formatProbabilityLabel(probability) {
                const percent = probability * 100;
                if (!Number.isFinite(percent)) {
                    return '0%';
                }
                if (percent >= 10) {
                    return `${percent.toFixed(0)}%`;
                }
                if (percent >= 1) {
                    return `${percent.toFixed(1)}%`;
                }
                return `${percent.toFixed(2)}%`;
            }

            function formatPriceTick(value) {
                if (!Number.isFinite(value)) {
                    return '';
                }
                const digits = value >= 100 ? 1 : 2;
                return `${new Intl.NumberFormat('ko-KR', {
                    minimumFractionDigits: digits,
                    maximumFractionDigits: digits
                }).format(value)}억`;
            }

            function buildWinRateChartSummary(params, results) {
                if (!results || !Array.isArray(results.bids) || !results.bids.length) {
                    return '그래프를 표시할 데이터가 없습니다.';
                }

                const lowRate = (results.low / params.openPrice) * 100;
                const highRate = (results.high / params.openPrice) * 100;
                const rangeText = `${lowRate.toFixed(2)}% ~ ${highRate.toFixed(2)}%`;
                const amountRange = `${formatAmount(results.low)} ~ ${formatAmount(results.high)}`;
                const bestBid = Number.isInteger(results.bestIndex) && results.bestIndex >= 0
                    ? results.bids[results.bestIndex]
                    : null;

                if (!bestBid) {
                    return `그래프는 ${rangeText} (${amountRange}) 범위의 투찰률 변화를 보여줍니다.`;
                }

                const probabilityPercent = bestBid.probability * 100;
                if (probabilityPercent <= 0) {
                    return `${rangeText} (${amountRange}) 범위에서는 낙찰 확률이 0% 수준으로 계산됩니다.`;
                }

                return `${formatAmount(bestBid.price)}(${bestBid.rate.toFixed(2)}%) 구간에서 낙찰 확률이 가장 높게 ${probabilityPercent.toFixed(1)}%입니다. 그래프 범위는 ${rangeText} (${amountRange})입니다.\n
                참고: 그래프의 후반부에 나타날 수 있는 평평한 구간은 경쟁사가 모두 임계값을 넘기지 못해 낙찰자가 높은 금액에서 발생하는 상황으로, 경쟁사들이 그 가격대에 금액을 제시할 확률이 거의 없어 경쟁사의 제시 가격에 상관 없이 일정하게 낮은 낙찰 확률이 유지될 수 있다는 것을 의미합니다.`;
            }

            function buildStrategyHint(probability) {
                if (probability >= 35) {
                    return '낙찰 가능성이 높은 구간입니다. 다른 조건만 충족된다면 과감한 투찰도 고려할 수 있습니다.';
                }
                if (probability >= 20) {
                    return '낙찰 가능성이 중간 수준입니다. 원가 및 리스크를 면밀히 점검하세요.';
                }
                if (probability > 0) {
                    return '낙찰 확률이 낮은 편이므로 대안 전략을 함께 고민하는 것이 좋습니다.';
                }
                return '해당 투찰률로는 낙찰이 불가능합니다. 상위 가격을 다시 검토하세요.';
            }

            function buildMarketInsight(params, results) {
                if (!results.bids.length) {
                    return '설정된 분포로 계산된 구간이 없어 시장 해석을 제공할 수 없습니다.';
                }

                const bestBid = results.bestIndex >= 0 ? results.bids[results.bestIndex] : null;
                if (!bestBid) {
                    return '계산된 투찰 구간이 없어 추가 해석을 제공할 수 없습니다.';
                }

                const rangeText = `${formatAmount(results.low)} ~ ${formatAmount(results.high)}`;
                const lowRate = (results.low / params.openPrice) * 100;
                const highRate = (results.high / params.openPrice) * 100;
                const totalCount = results.totalCompanyCount ?? (results.otherCompanyCount + 1);
                const competitorCount = results.otherCompanyCount;

                let insight = `임계값 A는 ${rangeText} (${lowRate.toFixed(2)}% ~ ${highRate.toFixed(2)}%) 범위에서 형성되며 평균은 ${formatAmount(results.mean)}입니다. `;
                insight += `총 참여 업체 수는 ${totalCount}곳(경쟁 ${competitorCount}곳)으로 설정했습니다. `;

                if (results.distribution) {
                    const dist = results.distribution;
                    insight += `경쟁 업체 제시가격 분포는 ${dist.type}(${dist.description})으로 가정했으며 평균 투찰률은 ${dist.rateMu.toFixed(2)}%, 표준편차는 ${dist.rateSigma.toFixed(2)}% 수준입니다. `;
                    if (dist.isMixture) {
                        let breakdownText = '';
                        if (Array.isArray(dist.components) && dist.components.length) {
                            breakdownText = dist.components
                                .map(component => {
                                    const ratioSource = Number.isFinite(component.weightPercent)
                                        ? component.weightPercent
                                        : Number.isFinite(component.weight)
                                            ? component.weight * 100
                                            : 0;
                                    const ratioText = Number.isFinite(ratioSource) ? ratioSource.toFixed(1) : '0.0';
                                    const detail = component.summary ? ` (${component.summary})` : '';
                                    return `${component.label} ${ratioText}%${detail}`;
                                })
                                .join(', ');
                        } else if (typeof dist.componentDetailSummary === 'string' && dist.componentDetailSummary) {
                            breakdownText = dist.componentDetailSummary.replace(/·/g, ',');
                        }
                        if (breakdownText) {
                            insight += ` 혼합 구성은 ${breakdownText}입니다.`;
                        }
                    }
                }

                if (bestBid.probability <= 0) {
                    const highestBid = results.bids[results.bids.length - 1];
                    const cap = Math.min(results.high, highestBid.price);
                    insight += `현재 설정에서는 임계값을 넘는 전략이 없어 낙찰이 어렵습니다. ${formatAmount(cap)} 이상의 금액도 검토하세요.`;
                    return insight;
                }

                insight += `${bestBid.rate.toFixed(2)}% (${formatAmount(bestBid.price)}) 투찰 시 낙찰 확률은 ${(bestBid.probability * 100).toFixed(1)}%입니다. `;
                insight += `임계값이 ${formatAmount(bestBid.thresholdUpper)} 이하로 형성되는 경우는 전체의 ${(bestBid.thresholdShare * 100).toFixed(1)}%이며, 이 구간에서 경쟁 업체 누적 비중은 ${(bestBid.competitorShareBelow * 100).toFixed(1)}%로 추정됩니다.`;

                if (results.leftoverProbability > 1e-6) {
                    const cap = Math.min(results.high, results.maxPrice);
                    insight += ` 또한 임계값이 ${formatAmount(cap)} 이상일 경우 낙찰자가 정해지지 않을 확률이 ${(results.leftoverProbability * 100).toFixed(1)}% 존재합니다.`;
                } else {
                    const coverage = 1 - results.leftoverProbability;
                    insight += ` 계산된 구간만으로도 ${(coverage * 100).toFixed(1)}%의 상황에서 낙찰자가 결정됩니다.`;
                }

                return insight;
            }

            function formatAmount(amount) {
                return new Intl.NumberFormat('ko-KR', { minimumFractionDigits: 2, maximumFractionDigits: 2 }).format(amount) + '억 원';
            }
        })();
    </script>
</body>
</html>
