<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>간편 입찰 전략 계산기</title>
    <style>
        :root {
            color-scheme: light;
            --bg-color: #f6f8fc;
            --text-color: #1f2933;
            --subtle-text: #64748b;
            --card-bg: #ffffff;
            --primary: #2563eb;
            --primary-dark: #1d4ed8;
            --border: #e2e8f0;
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: 'Pretendard', 'Segoe UI', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg-color);
            color: var(--text-color);
            line-height: 1.6;
        }

        .app {
            max-width: 760px;
            margin: 0 auto;
            padding: 32px 16px 48px;
        }

        .app-header {
            text-align: center;
            margin-bottom: 28px;
        }

        .app-header h1 {
            font-size: 26px;
            margin: 0 0 10px;
            font-weight: 700;
            color: #0f172a;
        }

        .app-header p {
            margin: 0;
            color: var(--subtle-text);
            font-size: 15px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 24px;
            box-shadow: 0 12px 32px rgba(15, 23, 42, 0.08);
        }

        .input-card {
            margin-bottom: 20px;
        }

        .field {
            display: flex;
            flex-direction: column;
            gap: 6px;
            margin-bottom: 16px;
        }

        .field label {
            font-size: 14px;
            font-weight: 600;
            color: #334155;
        }

        .field input,
        .field textarea,
        .field select {
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 12px 14px;
            font-size: 15px;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
        }

        .field textarea {
            resize: vertical;
            min-height: 96px;
        }

        .field input:focus,
        .field textarea:focus,
        .field select:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.16);
            outline: none;
        }

        .field-group {
            display: grid;
            gap: 12px;
            margin-bottom: 16px;
        }

        .field .field-hint {
            color: var(--subtle-text);
            font-size: 13px;
        }

        .action-row {
            display: flex;
            gap: 12px;
            margin-top: 8px;
        }

        .btn {
            flex: 1;
            border: none;
            border-radius: 12px;
            padding: 13px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.15s ease, box-shadow 0.15s ease, background 0.2s ease;
        }

        .btn-primary {
            background: var(--primary);
            color: #ffffff;
            box-shadow: 0 10px 24px rgba(37, 99, 235, 0.28);
        }

        .btn-primary:hover {
            background: var(--primary-dark);
            transform: translateY(-1px);
        }

        .btn-secondary {
            background: #f1f5f9;
            color: #1f2937;
        }

        .btn-secondary:hover {
            background: #e2e8f0;
        }

        .loading-card {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 16px;
            min-height: 170px;
            text-align: center;
            color: var(--subtle-text);
            font-size: 14px;
        }

        .spinner {
            width: 38px;
            height: 38px;
            border-radius: 50%;
            border: 4px solid #dbeafe;
            border-top-color: var(--primary);
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .result-card {
            display: flex;
            flex-direction: column;
            gap: 24px;
        }

        #resultSummary {
            font-size: 15px;
            color: #1f2937;
            display: grid;
            gap: 8px;
        }

        #resultSummary strong {
            color: #0f172a;
        }

        #resultSummary .hint {
            color: var(--subtle-text);
            font-size: 14px;
        }

        .result-grid {
            display: grid;
            gap: 16px;
            grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
        }

        .result-box {
            background: #f8fafc;
            border-radius: 14px;
            padding: 18px;
            border: 1px solid var(--border);
        }

        .result-box h3 {
            margin: 0 0 10px;
            font-size: 15px;
            color: #1f2937;
        }

        .result-box ul {
            list-style: none;
            padding: 0;
            margin: 0;
            display: grid;
            gap: 8px;
            font-size: 14px;
            color: #4b5563;
        }

        .result-box li strong {
            color: #111827;
        }

        .probability-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
            font-size: 14px;
            color: #475569;
        }

        .probability-row:last-child {
            margin-bottom: 0;
        }

        .probability-label {
            width: 70px;
            font-weight: 600;
            color: #111827;
        }

        .probability-bar {
            position: relative;
            flex: 1;
            height: 8px;
            background: #e2e8f0;
            border-radius: 999px;
            overflow: hidden;
        }

        .probability-fill {
            position: absolute;
            inset: 0;
            width: 0;
            background: linear-gradient(90deg, #2563eb, #3b82f6);
        }

        .probability-value {
            width: 58px;
            text-align: right;
            font-variant-numeric: tabular-nums;
            color: #1f2937;
        }

        .note-card {
            background: #f1f5f9;
            border-radius: 14px;
            padding: 18px;
            border: 1px solid var(--border);
            font-size: 14px;
            color: #475569;
        }

        .note-card h3 {
            margin: 0 0 6px;
            font-size: 15px;
            color: #1f2937;
        }

        .app-footer {
            margin-top: 20px;
            text-align: center;
            font-size: 12px;
            color: #94a3b8;
        }

        [hidden] {
            display: none !important;
        }

        @media (max-width: 640px) {
            .action-row {
                flex-direction: column;
            }

            .btn {
                width: 100%;
            }

            .app {
                padding: 24px 14px 40px;
            }
        }
    </style>
</head>
<body>
    <div class="app">
        <header class="app-header">
            <h1>간편 입찰 전략 계산기</h1>
            <p>핵심 수치만 입력하면 가장 유리한 투찰 구간을 바로 확인할 수 있습니다.</p>
        </header>

        <form id="simulationForm" class="card input-card">
            <div class="field">
                <label for="openPrice">공개가격 (억원)</label>
                <input type="number" id="openPrice" name="openPrice" min="1" step="0.1" value="100">
            </div>
            <div class="field">
                <label for="companyCount">참여 업체 수</label>
                <input type="number" id="companyCount" name="companyCount" min="1" step="1" value="8">
                <small class="field-hint">우리 회사를 포함한 전체 참여 업체 수를 입력하세요.</small>
            </div>
            <div class="field">
                <label for="distributionType">경쟁 업체 분포</label>
                <select id="distributionType" name="distributionType">
                    <option value="uniform">균등분포 (동일 확률)</option>
                    <option value="triangular">삼각분포 (중앙값 쏠림)</option>
                    <option value="truncnormal" selected>절단정규분포 (평균/표준편차)</option>
                </select>
                <small class="field-hint">경쟁 업체 제시가격이 따른다고 가정하는 분포를 선택하세요.</small>
            </div>
            <div id="distributionParams" class="field-group" aria-live="polite"></div>
            <div class="action-row">
                <button type="submit" class="btn btn-primary">분석 실행</button>
                <button type="button" id="resetButton" class="btn btn-secondary">초기화</button>
            </div>
        </form>

        <div id="loadingIndicator" class="card loading-card" hidden>
            <div class="spinner" aria-hidden="true"></div>
            <p>확률 분포를 계산하는 중입니다...</p>
            <small>잠시만 기다려 주세요.</small>
        </div>

        <section id="resultSection" class="card result-card" hidden aria-live="polite">
            <div id="resultSummary"></div>

            <div class="result-grid">
                <div class="result-box">
                    <h3>핵심 지표</h3>
                    <div id="strategyNotes"></div>
                </div>
                <div class="result-box">
                    <h3>낙찰 확률 상위 구간</h3>
                    <div id="probabilityList"></div>
                </div>
            </div>

            <div class="note-card">
                <h3>시장 해석</h3>
                <p id="marketInsight"></p>
            </div>
        </section>

        <footer class="app-footer">
            ※ 본 계산기는 참고용 이론적 확률 계산 결과를 제공합니다. 실제 투찰 전 추가 검토가 필요합니다.
        </footer>
    </div>

    <script>
        (() => {
            const DEFAULTS = {
                openPrice: 100,
                companyCount: 8,
                distributionType: 'truncnormal',
                distributionParams: {
                    uniform: { minRate: 78.50, maxRate: 81.50 },
                    triangular: { minRate: 78.50, modeRate: 80.00, maxRate: 81.50 },
                    truncnormal: { meanRate: 80.00, stdRate: 0.45 }
                }
            };

            const BASE_RATE = 0.79995;
            const RANGE_RATIO = 0.02;
            const SAMPLE_SIZE = 15;
            const PICK_SIZE = 4;
            const CANDIDATE_GRID_POINTS = 121;
            const RATE_MIN = 50;
            const RATE_MAX = 120;
            const RATE_STD_MIN = 0.01;
            const RATE_STD_MAX = 10;

            const form = document.getElementById('simulationForm');
            const loadingIndicator = document.getElementById('loadingIndicator');
            const resultSection = document.getElementById('resultSection');
            const resultSummary = document.getElementById('resultSummary');
            const strategyNotes = document.getElementById('strategyNotes');
            const probabilityList = document.getElementById('probabilityList');
            const marketInsight = document.getElementById('marketInsight');
            const resetButton = document.getElementById('resetButton');
            const companyCountInput = document.getElementById('companyCount');
            const distributionTypeSelect = document.getElementById('distributionType');
            const distributionParamsContainer = document.getElementById('distributionParams');

            let currentDistributionType = distributionTypeSelect.value || DEFAULTS.distributionType;
            if (!currentDistributionType) {
                currentDistributionType = DEFAULTS.distributionType;
                distributionTypeSelect.value = currentDistributionType;
            }

            const distributionParamState = {
                uniform: { ...DEFAULTS.distributionParams.uniform },
                triangular: { ...DEFAULTS.distributionParams.triangular },
                truncnormal: { ...DEFAULTS.distributionParams.truncnormal }
            };

            renderDistributionParams(currentDistributionType);

            form.addEventListener('submit', event => {
                event.preventDefault();
                runAnalysis();
            });

            distributionTypeSelect.addEventListener('change', event => {
                persistDistributionParams();
                currentDistributionType = event.target.value || DEFAULTS.distributionType;
                if (!currentDistributionType) {
                    currentDistributionType = DEFAULTS.distributionType;
                }
                renderDistributionParams(currentDistributionType);
                runAnalysis();
            });

            resetButton.addEventListener('click', () => {
                form.reset();
                resetDistributionParamState();
                currentDistributionType = distributionTypeSelect.value || DEFAULTS.distributionType;
                if (!currentDistributionType) {
                    currentDistributionType = DEFAULTS.distributionType;
                    distributionTypeSelect.value = currentDistributionType;
                }
                renderDistributionParams(currentDistributionType);
                runAnalysis();
            });

            runAnalysis();

            function runAnalysis() {
                showLoading();

                window.setTimeout(() => {
                    const params = collectFormData();
                    const results = analyzeBids(params);
                    hideLoading();
                    displayResults(params, results);
                }, 30);
            }

            function showLoading() {
                loadingIndicator.hidden = false;
                resultSection.hidden = true;
            }

            function hideLoading() {
                loadingIndicator.hidden = true;
            }

            function collectFormData() {
                persistDistributionParams();
                const openPrice = sanitizeNumber(document.getElementById('openPrice').value, DEFAULTS.openPrice, 1, 10000);
                const companyCount = sanitizeInteger(companyCountInput.value, DEFAULTS.companyCount, 1, 60);
                const distributionType = distributionTypeSelect.value || DEFAULTS.distributionType;
                const distributionParams = { ...(distributionParamState[distributionType] ?? {}) };
                return { openPrice, companyCount, distributionType, distributionParams };
            }

            function sanitizeNumber(value, fallback, min = -Infinity, max = Infinity) {
                const parsed = Number.parseFloat(value);
                if (!Number.isFinite(parsed)) {
                    return fallback;
                }
                const lower = Number.isFinite(min) ? min : -Infinity;
                const upper = Number.isFinite(max) ? max : Infinity;
                return Math.min(upper, Math.max(lower, parsed));
            }

            function sanitizeInteger(value, fallback, min = -Infinity, max = Infinity) {
                const parsed = Number.parseInt(value, 10);
                if (!Number.isFinite(parsed)) {
                    return fallback;
                }
                const lower = Number.isFinite(min) ? min : -Infinity;
                const upper = Number.isFinite(max) ? max : Infinity;
                const clamped = Math.min(upper, Math.max(lower, parsed));
                return Math.trunc(clamped);
            }

            function formatRateValue(value, digits = 2) {
                return Number.isFinite(value) ? value.toFixed(digits) : '';
            }

            function createParamInput({ id, label, key, value, min, max, step = '0.01', digits = 2, hint }) {
                const minAttr = Number.isFinite(min) ? ` min="${min}" data-min="${min}"` : '';
                const maxAttr = Number.isFinite(max) ? ` max="${max}" data-max="${max}"` : '';
                const stepAttr = step ? ` step="${step}"` : '';
                const digitsAttr = ` data-digits="${digits}"`;
                const safeValue = formatRateValue(value, digits);
                return `
                    <div class="field">
                        <label for="${id}">${label}</label>
                        <input type="number" id="${id}" data-param="${key}"${digitsAttr}${minAttr}${maxAttr}${stepAttr} value="${safeValue}">
                        ${hint ? `<small class="field-hint">${hint}</small>` : ''}
                    </div>
                `;
            }

            function renderDistributionParams(type) {
                const defaults = DEFAULTS.distributionParams[type] ?? {};
                const state = distributionParamState[type] ?? { ...defaults };
                distributionParamState[type] = state;

                let fieldsHtml = '';
                if (type === 'uniform') {
                    fieldsHtml = [
                        createParamInput({
                            id: 'uniformMinRate',
                            label: '분포 하한 투찰률 (%)',
                            key: 'minRate',
                            value: state.minRate ?? defaults.minRate,
                            min: RATE_MIN,
                            max: RATE_MAX,
                            hint: '경쟁 업체가 낼 가능성이 가장 낮은 투찰률'
                        }),
                        createParamInput({
                            id: 'uniformMaxRate',
                            label: '분포 상한 투찰률 (%)',
                            key: 'maxRate',
                            value: state.maxRate ?? defaults.maxRate,
                            min: RATE_MIN,
                            max: RATE_MAX,
                            hint: '경쟁 업체가 낼 가능성이 가장 높은 투찰률'
                        })
                    ].join('');
                } else if (type === 'triangular') {
                    fieldsHtml = [
                        createParamInput({
                            id: 'triMinRate',
                            label: '최솟값 투찰률 (%)',
                            key: 'minRate',
                            value: state.minRate ?? defaults.minRate,
                            min: RATE_MIN,
                            max: RATE_MAX,
                            hint: '경쟁 업체 투찰률의 가능한 최솟값'
                        }),
                        createParamInput({
                            id: 'triModeRate',
                            label: '최빈값 투찰률 (%)',
                            key: 'modeRate',
                            value: state.modeRate ?? defaults.modeRate,
                            min: RATE_MIN,
                            max: RATE_MAX,
                            hint: '가장 가능성이 높은 투찰률 (중앙값 역할)'
                        }),
                        createParamInput({
                            id: 'triMaxRate',
                            label: '최댓값 투찰률 (%)',
                            key: 'maxRate',
                            value: state.maxRate ?? defaults.maxRate,
                            min: RATE_MIN,
                            max: RATE_MAX,
                            hint: '경쟁 업체 투찰률의 가능한 최댓값'
                        })
                    ].join('');
                } else {
                    fieldsHtml = [
                        createParamInput({
                            id: 'truncMeanRate',
                            label: '평균 투찰률 (%)',
                            key: 'meanRate',
                            value: state.meanRate ?? defaults.meanRate,
                            min: RATE_MIN,
                            max: RATE_MAX,
                            hint: '경쟁 업체의 평균 투찰 수준'
                        }),
                        createParamInput({
                            id: 'truncStdRate',
                            label: '표준편차 (%)',
                            key: 'stdRate',
                            value: state.stdRate ?? defaults.stdRate,
                            min: RATE_STD_MIN,
                            max: RATE_STD_MAX,
                            hint: '평균 대비 분산(흩어짐) 정도'
                        })
                    ].join('');
                }

                distributionParamsContainer.innerHTML = fieldsHtml;
            }

            function persistDistributionParams() {
                const inputs = distributionParamsContainer.querySelectorAll('[data-param]');
                if (!inputs.length) {
                    return;
                }
                const type = currentDistributionType;
                const defaults = DEFAULTS.distributionParams[type] ?? {};
                const state = distributionParamState[type] ?? { ...defaults };
                distributionParamState[type] = state;

                inputs.forEach(input => {
                    const key = input.dataset.param;
                    if (!key) {
                        return;
                    }
                    const min = input.dataset.min ? Number.parseFloat(input.dataset.min) : -Infinity;
                    const max = input.dataset.max ? Number.parseFloat(input.dataset.max) : Infinity;
                    const digits = input.dataset.digits ? Number.parseInt(input.dataset.digits, 10) : 2;
                    const fallback = Number.isFinite(state[key]) ? state[key] : defaults[key];
                    const sanitized = sanitizeNumber(input.value, fallback, min, max);
                    state[key] = sanitized;
                    input.value = formatRateValue(sanitized, digits);
                });
            }

            function resetDistributionParamState() {
                for (const [type, defaults] of Object.entries(DEFAULTS.distributionParams)) {
                    distributionParamState[type] = { ...defaults };
                }
            }

            function analyzeBids(params) {
                const basePrice = params.openPrice * BASE_RATE;
                const low = basePrice * (1 - RANGE_RATIO);
                const high = basePrice * (1 + RANGE_RATIO);
                const mean = (low + high) / 2;
                const stdDev = (high - low) / Math.sqrt(12 * PICK_SIZE);

                const distribution = buildCompetitorDistributionFromSelection(params, low, high);
                const otherCompanyCount = Math.max(0, (params.companyCount ?? DEFAULTS.companyCount) - 1);
                const totalCompanyCount = otherCompanyCount + 1;

                const integrationGrid = createIntegrationGrid(low, high, 4096);
                const averagePdfValues = integrationGrid.map(value => averagePdf(value, low, high, PICK_SIZE));
                const distributionCdfValues = integrationGrid.map(value => distribution.cdf(value));

                const results = [];
                let bestIndex = -1;
                let maxProbability = -Infinity;

                for (let idx = 0; idx < CANDIDATE_GRID_POINTS; idx++) {
                    const ratio = CANDIDATE_GRID_POINTS > 1 ? idx / (CANDIDATE_GRID_POINTS - 1) : 0;
                    const price = low + (high - low) * ratio;
                    const rate = (price / params.openPrice) * 100;
                    const probability = computeWinProbability(
                        price,
                        low,
                        high,
                        otherCompanyCount,
                        distribution,
                        integrationGrid,
                        averagePdfValues,
                        distributionCdfValues,
                        PICK_SIZE
                    );
                    const thresholdUpper = Math.min(price, high);
                    const thresholdShare = averageCdf(thresholdUpper, low, high, PICK_SIZE);
                    const competitorShareBelow = clamp01(distribution.cdf(price));

                    const entry = {
                        rate,
                        price,
                        probability,
                        thresholdUpper,
                        thresholdShare,
                        competitorShareBelow
                    };

                    results.push(entry);

                    if (probability > maxProbability) {
                        maxProbability = probability;
                        bestIndex = idx;
                    }
                }

                const maxPrice = results.reduce((acc, item) => Math.max(acc, item.price), low);
                const coverage = averageCdf(Math.min(maxPrice, high), low, high, PICK_SIZE);
                const leftoverProbability = Math.max(0, 1 - coverage);

                const topIndices = results
                    .map((_, idx) => idx)
                    .sort((a, b) => results[b].probability - results[a].probability)
                    .slice(0, Math.min(5, results.length));

                return {
                    basePrice,
                    low,
                    high,
                    mean,
                    stdDev,
                    bids: results,
                    bestIndex,
                    topIndices,
                    leftoverProbability,
                    otherCompanyCount,
                    totalCompanyCount,
                    distribution,
                    maxPrice
                };
            }

            function createIntegrationGrid(low, high, steps = 4096) {
                const pointCount = Math.max(2, Math.trunc(steps));
                const result = new Array(pointCount);
                const step = (high - low) / (pointCount - 1);
                for (let idx = 0; idx < pointCount; idx++) {
                    result[idx] = low + step * idx;
                }
                return result;
            }

            function computeWinProbability(price, low, high, otherCompanyCount, distribution, grid, averagePdfValues, distributionCdfValues, pickSize) {
                if (price <= low) {
                    return 0;
                }

                const upper = Math.min(price, high);
                if (upper <= low) {
                    return 0;
                }

                const gp = clamp01(distribution.cdf(price));
                const exponent = otherCompanyCount;

                const integrand = (pdfValue, cdfValue) => {
                    if (pdfValue <= 0) {
                        return 0;
                    }
                    const base = clamp01(cdfValue + 1 - gp);
                    if (base <= 0) {
                        return 0;
                    }
                    return pdfValue * Math.pow(base, exponent);
                };

                let integral = 0;
                let previousA = grid[0];
                let previousIntegrand = integrand(averagePdfValues[0], distributionCdfValues[0]);

                for (let idx = 1; idx < grid.length; idx++) {
                    const currentA = grid[idx];
                    const currentIntegrand = integrand(averagePdfValues[idx], distributionCdfValues[idx]);

                    if (currentA >= upper) {
                        const finalPdf = averagePdf(upper, low, high, pickSize);
                        const finalCdf = distribution.cdf(upper);
                        const finalIntegrand = integrand(finalPdf, finalCdf);
                        integral += 0.5 * (upper - previousA) * (previousIntegrand + finalIntegrand);
                        previousA = upper;
                        previousIntegrand = finalIntegrand;
                        break;
                    } else {
                        integral += 0.5 * (currentA - previousA) * (previousIntegrand + currentIntegrand);
                        previousA = currentA;
                        previousIntegrand = currentIntegrand;
                    }
                }

                if (previousA < upper) {
                    const finalPdf = averagePdf(upper, low, high, pickSize);
                    const finalCdf = distribution.cdf(upper);
                    const finalIntegrand = integrand(finalPdf, finalCdf);
                    integral += 0.5 * (upper - previousA) * (previousIntegrand + finalIntegrand);
                }

                return clamp01(integral);
            }

            function averageCdf(value, low, high, pickSize) {
                if (value <= low) {
                    return 0;
                }
                if (value >= high) {
                    return 1;
                }
                const scale = high - low;
                const z = (pickSize * (value - low)) / scale;
                return irwinHallCdf(z, pickSize);
            }

            function averagePdf(value, low, high, pickSize) {
                if (value <= low || value >= high) {
                    return 0;
                }
                const scale = high - low;
                const z = (pickSize * (value - low)) / scale;
                return (pickSize / scale) * irwinHallPdf(z, pickSize);
            }

            function irwinHallCdf(z, n) {
                if (z <= 0) {
                    return 0;
                }
                if (z >= n) {
                    return 1;
                }

                const upper = Math.floor(z);
                let sum = 0;

                for (let k = 0; k <= upper; k++) {
                    const sign = k % 2 === 0 ? 1 : -1;
                    sum += sign * combination(n, k) * Math.pow(z - k, n);
                }

                return sum / factorial(n);
            }

            function irwinHallPdf(z, n) {
                if (z <= 0 || z >= n) {
                    return 0;
                }

                const upper = Math.floor(z);
                let sum = 0;

                for (let k = 0; k <= upper; k++) {
                    const sign = k % 2 === 0 ? 1 : -1;
                    sum += sign * combination(n, k) * Math.pow(z - k, n - 1);
                }

                return sum / factorial(n - 1);
            }

            function combination(n, k) {
                if (k < 0 || k > n) {
                    return 0;
                }
                if (k === 0 || k === n) {
                    return 1;
                }
                let result = 1;
                for (let i = 1; i <= k; i++) {
                    result *= (n - (k - i));
                    result /= i;
                }
                return result;
            }

            function factorial(n) {
                let result = 1;
                for (let i = 2; i <= n; i++) {
                    result *= i;
                }
                return result;
            }

            function buildCompetitorDistributionFromSelection(params, low, high) {
                const type = params.distributionType || DEFAULTS.distributionType;
                const openPrice = params.openPrice;
                const settings = params.distributionParams ?? {};
                const defaults = DEFAULTS.distributionParams;
                const toPrice = rate => openPrice * (rate / 100);
                const toRate = price => (price / openPrice) * 100;

                const createUniformFromRates = () => {
                    const uniformDefaults = defaults.uniform;
                    let minRate = sanitizeNumber(settings.minRate, uniformDefaults.minRate, RATE_MIN, RATE_MAX);
                    let maxRate = sanitizeNumber(settings.maxRate, uniformDefaults.maxRate, RATE_MIN, RATE_MAX);
                    if (!Number.isFinite(minRate)) minRate = uniformDefaults.minRate;
                    if (!Number.isFinite(maxRate)) maxRate = uniformDefaults.maxRate;
                    if (minRate > maxRate) {
                        [minRate, maxRate] = [maxRate, minRate];
                    }
                    if (Math.abs(maxRate - minRate) < 1e-6) {
                        maxRate = minRate + 0.1;
                    }
                    const distribution = createUniformDistribution(toPrice(minRate), toPrice(maxRate));
                    const description = `하한 ${minRate.toFixed(2)}% ~ 상한 ${maxRate.toFixed(2)}%`;
                    return {
                        ...enrichDistribution(distribution, '균등 분포', openPrice, description),
                        rateMin: Math.min(minRate, maxRate),
                        rateMax: Math.max(minRate, maxRate)
                    };
                };

                const createTriangularFromRates = () => {
                    const triDefaults = defaults.triangular;
                    let minRate = sanitizeNumber(settings.minRate, triDefaults.minRate, RATE_MIN, RATE_MAX);
                    let modeRate = sanitizeNumber(settings.modeRate, triDefaults.modeRate, RATE_MIN, RATE_MAX);
                    let maxRate = sanitizeNumber(settings.maxRate, triDefaults.maxRate, RATE_MIN, RATE_MAX);
                    if (!Number.isFinite(minRate)) minRate = triDefaults.minRate;
                    if (!Number.isFinite(modeRate)) modeRate = triDefaults.modeRate;
                    if (!Number.isFinite(maxRate)) maxRate = triDefaults.maxRate;
                    if (minRate > maxRate) {
                        [minRate, maxRate] = [maxRate, minRate];
                    }
                    if (Math.abs(maxRate - minRate) < 1e-6) {
                        maxRate = minRate + 0.1;
                    }
                    modeRate = clamp(modeRate, minRate, maxRate);
                    const distribution = createTriangularDistribution(toPrice(minRate), toPrice(modeRate), toPrice(maxRate));
                    const description = `최솟값 ${minRate.toFixed(2)}% / 최빈값 ${modeRate.toFixed(2)}% / 최댓값 ${maxRate.toFixed(2)}%`;
                    return {
                        ...enrichDistribution(distribution, '삼각 분포', openPrice, description),
                        rateMin: minRate,
                        rateMode: modeRate,
                        rateMax: maxRate
                    };
                };

                const createTruncNormalFromRates = () => {
                    const truncDefaults = defaults.truncnormal;
                    let meanRate = sanitizeNumber(settings.meanRate, truncDefaults.meanRate, RATE_MIN, RATE_MAX);
                    let stdRate = sanitizeNumber(settings.stdRate, truncDefaults.stdRate, RATE_STD_MIN, RATE_STD_MAX);
                    if (!Number.isFinite(meanRate)) meanRate = truncDefaults.meanRate;
                    if (!Number.isFinite(stdRate) || stdRate <= 0) stdRate = truncDefaults.stdRate;
                    const mu = toPrice(meanRate);
                    const sigma = Math.max(openPrice * (stdRate / 100), (high - low) / 200, Math.abs(mu) * 1e-6);
                    const distribution = buildTruncatedNormalDistribution(low, high, mu, sigma);
                    const description = `평균 ${meanRate.toFixed(2)}%, 표준편차 ${stdRate.toFixed(2)}%`;
                    return {
                        ...enrichDistribution(distribution, '절단 정규 분포', openPrice, description),
                        rateMean: meanRate,
                        rateStd: stdRate,
                        supportRateLow: toRate(low),
                        supportRateHigh: toRate(high)
                    };
                };

                switch (type) {
                    case 'uniform':
                        return createUniformFromRates();
                    case 'triangular':
                        return createTriangularFromRates();
                    case 'truncnormal':
                    default:
                        return createTruncNormalFromRates();
                }
            }

            function enrichDistribution(baseDistribution, typeLabel, openPrice, description) {
                const mu = Number.isFinite(baseDistribution.mu) ? baseDistribution.mu : 0;
                const sigma = Number.isFinite(baseDistribution.sigma) ? baseDistribution.sigma : 0;
                return {
                    ...baseDistribution,
                    type: typeLabel,
                    mu,
                    sigma,
                    rateMu: (mu / openPrice) * 100,
                    rateSigma: (sigma / openPrice) * 100,
                    description
                };
            }

            function buildTruncatedNormalDistribution(low, high, mu, sigma) {
                const range = high - low;
                let adjustedMu = clamp(mu, low + 0.01 * range, high - 0.01 * range);
                let adjustedSigma = Math.max(sigma, range / 40, 1e-6 * Math.abs(mu));
                let alpha;
                let beta;
                let denom;

                for (let attempt = 0; attempt < 6; attempt++) {
                    alpha = (low - adjustedMu) / adjustedSigma;
                    beta = (high - adjustedMu) / adjustedSigma;
                    denom = standardNormalCdf(beta) - standardNormalCdf(alpha);
                    if (denom > 1e-8) {
                        break;
                    }
                    adjustedSigma *= 1.5;
                }

                if (!Number.isFinite(denom) || denom <= 1e-8) {
                    return createUniformDistribution(low, high);
                }

                return {
                    type: '절단 정규',
                    mu: adjustedMu,
                    sigma: adjustedSigma,
                    pdf(value) {
                        if (value < low || value > high) {
                            return 0;
                        }
                        const z = (value - adjustedMu) / adjustedSigma;
                        return standardNormalPdf(z) / (adjustedSigma * denom);
                    },
                    cdf(value) {
                        if (value <= low) {
                            return 0;
                        }
                        if (value >= high) {
                            return 1;
                        }
                        const z = (value - adjustedMu) / adjustedSigma;
                        const numerator = standardNormalCdf(z) - standardNormalCdf(alpha);
                        return clamp01(numerator / denom);
                    }
                };
            }

            function createUniformDistribution(low, high) {
                const range = Math.max(high - low, 1e-9);
                const mu = (low + high) / 2;
                const sigma = range / Math.sqrt(12);
                return {
                    type: '균등',
                    mu,
                    sigma,
                    pdf(value) {
                        if (value < low || value > high) {
                            return 0;
                        }
                        return 1 / range;
                    },
                    cdf(value) {
                        if (value <= low) {
                            return 0;
                        }
                        if (value >= high) {
                            return 1;
                        }
                        return (value - low) / range;
                    }
                };
            }

            function createTriangularDistribution(min, mode, max) {
                const lower = Math.min(min, max);
                const upper = Math.max(min, max);

                if (!Number.isFinite(lower) || !Number.isFinite(upper)) {
                    return createUniformDistribution(min, max);
                }

                const range = upper - lower;
                if (range < 1e-6) {
                    return createUniformDistribution(lower, upper);
                }

                const epsilon = Math.max(range * 1e-3, 1e-6 * Math.max(1, Math.abs(upper)));
                let peak = Number.isFinite(mode) ? clamp(mode, lower + epsilon, upper - epsilon) : lower + range / 2;

                if (peak <= lower) {
                    peak = lower + epsilon;
                }
                if (peak >= upper) {
                    peak = upper - epsilon;
                }

                const leftWidth = peak - lower;
                const rightWidth = upper - peak;
                if (leftWidth <= 0 || rightWidth <= 0) {
                    return createUniformDistribution(lower, upper);
                }

                const mu = (lower + peak + upper) / 3;
                const variance = (lower * lower + peak * peak + upper * upper - lower * peak - lower * upper - peak * upper) / 18;
                const sigma = Math.sqrt(Math.max(variance, 0));

                return {
                    type: '삼각',
                    mu,
                    sigma,
                    pdf(value) {
                        if (value < lower || value > upper) {
                            return 0;
                        }
                        if (value <= peak) {
                            return (2 * (value - lower)) / ((upper - lower) * leftWidth);
                        }
                        return (2 * (upper - value)) / ((upper - lower) * rightWidth);
                    },
                    cdf(value) {
                        if (value <= lower) {
                            return 0;
                        }
                        if (value >= upper) {
                            return 1;
                        }
                        if (value <= peak) {
                            return Math.pow(value - lower, 2) / ((upper - lower) * leftWidth);
                        }
                        return 1 - Math.pow(upper - value, 2) / ((upper - lower) * rightWidth);
                    }
                };
            }

            function standardNormalPdf(x) {
                return Math.exp(-0.5 * x * x) / Math.sqrt(2 * Math.PI);
            }

            function standardNormalCdf(x) {
                return 0.5 * (1 + erf(x / Math.SQRT2));
            }

            function erf(x) {
                const sign = x >= 0 ? 1 : -1;
                const absX = Math.abs(x);
                const t = 1 / (1 + 0.3275911 * absX);
                const a1 = 0.254829592;
                const a2 = -0.284496736;
                const a3 = 1.421413741;
                const a4 = -1.453152027;
                const a5 = 1.061405429;
                const poly = (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t;
                const expTerm = Math.exp(-absX * absX);
                return sign * (1 - poly * expTerm);
            }

            function clamp(value, min, max) {
                return Math.min(max, Math.max(min, value));
            }

            function clamp01(value) {
                return clamp(value, 0, 1);
            }

            function displayResults(params, results) {
                if (!results.bids.length) {
                    resultSummary.innerHTML = `
                        <p>설정한 분포로 계산 가능한 투찰 구간이 없습니다. 입력값을 다시 확인해주세요.</p>
                    `;
                    strategyNotes.innerHTML = '';
                    probabilityList.innerHTML = '';
                    marketInsight.textContent = '경쟁 분포와 업체 수 설정을 조정한 뒤 다시 계산해주세요.';
                    resultSection.hidden = false;
                    return;
                }

                const bestBid = results.bestIndex >= 0 ? results.bids[results.bestIndex] : null;
                const probabilityPercent = bestBid ? bestBid.probability * 100 : 0;
                const expectedAmount = bestBid ? bestBid.price : 0;

                resultSummary.innerHTML = `
                    <p><strong>${bestBid.rate.toFixed(2)}%</strong> 투찰 시 낙찰 확률은 <strong>${probabilityPercent.toFixed(1)}%</strong>입니다.</p>
                    <p>해당 제시금액은 약 <strong>${formatAmount(expectedAmount)}</strong>입니다.</p>
                    <p class="hint">${buildStrategyHint(probabilityPercent)}</p>
                `;

                const rangePercent = (RANGE_RATIO * 100).toFixed(2);
                const lowRate = (results.low / params.openPrice) * 100;
                const highRate = (results.high / params.openPrice) * 100;
                const notes = [
                    `기준가격: <strong>${formatAmount(results.basePrice)}</strong>`,
                    `임계값 추정 범위 (±${rangePercent}%): <strong>${formatAmount(results.low)} ~ ${formatAmount(results.high)}</strong> (${lowRate.toFixed(2)}% ~ ${highRate.toFixed(2)}%)`,
                    `표본 평균 기대값: <strong>${formatAmount(results.mean)}</strong>`,
                    `표본 평균 분포 표준편차: <strong>${formatAmount(results.stdDev)}</strong>`,
                    `총 참여 업체 수: <strong>${results.totalCompanyCount}</strong>곳`,
                    `경쟁 업체 수(우리 제외): <strong>${results.otherCompanyCount}</strong>곳`
                ];

                if (results.distribution) {
                    const dist = results.distribution;
                    notes.push(`경쟁 분포 가정: <strong>${dist.type}</strong> (${dist.description})`);
                    notes.push(`분포 평균/표준편차: <strong>${formatAmount(dist.mu)}</strong> / <strong>${formatAmount(dist.sigma)}</strong> (투찰률 ${dist.rateMu.toFixed(2)}% / ${dist.rateSigma.toFixed(2)}%)`);
                }

                notes.push(`분석 방법: <strong>${SAMPLE_SIZE}개 중 ${PICK_SIZE}개 평균분포 + 타업체 연속분포 적분</strong>`);

                if (results.leftoverProbability > 1e-6) {
                    notes.push(`임계값이 최고 투찰금액을 초과해 낙찰자가 정해지지 않을 확률: <strong>${(results.leftoverProbability * 100).toFixed(1)}%</strong>`);
                } else {
                    notes.push('임계값 상단까지 전 구간을 포함해 계산되었습니다.');
                }

                strategyNotes.innerHTML = `<ul>${notes.map(note => `<li>${note}</li>`).join('')}</ul>`;

                probabilityList.innerHTML = results.topIndices.map(idx => {
                    const bid = results.bids[idx];
                    const probability = bid.probability * 100;
                    const fillWidth = Math.max(3, Math.min(100, probability));
                    const tooltip = [
                        `제시금액 ${formatAmount(bid.price)}`,
                        `임계값 커버 ${(bid.thresholdShare * 100).toFixed(1)}%`,
                        `타 업체 ≤ ${bid.rate.toFixed(2)}% 비중 ${(bid.competitorShareBelow * 100).toFixed(1)}%`
                    ].join(' | ');
                    return `
                        <div class="probability-row">
                            <div class="probability-label" title="${tooltip}">${bid.rate.toFixed(2)}%</div>
                            <div class="probability-bar">
                                <div class="probability-fill" style="width: ${fillWidth}%;"></div>
                            </div>
                            <div class="probability-value">${probability.toFixed(2)}%</div>
                        </div>
                    `;
                }).join('');

                marketInsight.textContent = buildMarketInsight(params, results);

                resultSection.hidden = false;
            }

            function buildStrategyHint(probability) {
                if (probability >= 35) {
                    return '낙찰 가능성이 높은 구간입니다. 다른 조건만 충족된다면 과감한 투찰도 고려할 수 있습니다.';
                }
                if (probability >= 20) {
                    return '낙찰 가능성이 중간 수준입니다. 원가 및 리스크를 면밀히 점검하세요.';
                }
                if (probability > 0) {
                    return '낙찰 확률이 낮은 편이므로 대안 전략을 함께 고민하는 것이 좋습니다.';
                }
                return '해당 투찰률로는 낙찰이 불가능합니다. 상위 가격을 다시 검토하세요.';
            }

            function buildMarketInsight(params, results) {
                if (!results.bids.length) {
                    return '설정된 분포로 계산된 구간이 없어 시장 해석을 제공할 수 없습니다.';
                }

                const bestBid = results.bestIndex >= 0 ? results.bids[results.bestIndex] : null;
                if (!bestBid) {
                    return '계산된 투찰 구간이 없어 추가 해석을 제공할 수 없습니다.';
                }

                const rangeText = `${formatAmount(results.low)} ~ ${formatAmount(results.high)}`;
                const lowRate = (results.low / params.openPrice) * 100;
                const highRate = (results.high / params.openPrice) * 100;
                const totalCount = results.totalCompanyCount ?? (results.otherCompanyCount + 1);
                const competitorCount = results.otherCompanyCount;

                let insight = `임계값 A는 ${rangeText} (${lowRate.toFixed(2)}% ~ ${highRate.toFixed(2)}%) 범위에서 형성되며 평균은 ${formatAmount(results.mean)}입니다. `;
                insight += `총 참여 업체 수는 ${totalCount}곳(경쟁 ${competitorCount}곳)으로 설정했습니다. `;

                if (results.distribution) {
                    const dist = results.distribution;
                    insight += `경쟁 업체 제시가격 분포는 ${dist.type}(${dist.description})으로 가정했으며 평균 투찰률은 ${dist.rateMu.toFixed(2)}%, 표준편차는 ${dist.rateSigma.toFixed(2)}% 수준입니다. `;
                }

                if (bestBid.probability <= 0) {
                    const highestBid = results.bids[results.bids.length - 1];
                    const cap = Math.min(results.high, highestBid.price);
                    insight += `현재 설정에서는 임계값을 넘는 전략이 없어 낙찰이 어렵습니다. ${formatAmount(cap)} 이상의 금액도 검토하세요.`;
                    return insight;
                }

                insight += `${bestBid.rate.toFixed(2)}% (${formatAmount(bestBid.price)}) 투찰 시 낙찰 확률은 ${(bestBid.probability * 100).toFixed(1)}%입니다. `;
                insight += `임계값이 ${formatAmount(bestBid.thresholdUpper)} 이하로 형성되는 경우는 전체의 ${(bestBid.thresholdShare * 100).toFixed(1)}%이며, 이 구간에서 경쟁 업체 누적 비중은 ${(bestBid.competitorShareBelow * 100).toFixed(1)}%로 추정됩니다.`;

                if (results.leftoverProbability > 1e-6) {
                    const cap = Math.min(results.high, results.maxPrice);
                    insight += ` 또한 임계값이 ${formatAmount(cap)} 이상일 경우 낙찰자가 정해지지 않을 확률이 ${(results.leftoverProbability * 100).toFixed(1)}% 존재합니다.`;
                } else {
                    const coverage = 1 - results.leftoverProbability;
                    insight += ` 계산된 구간만으로도 ${(coverage * 100).toFixed(1)}%의 상황에서 낙찰자가 결정됩니다.`;
                }

                return insight;
            }

            function formatAmount(amount) {
                return new Intl.NumberFormat('ko-KR', { minimumFractionDigits: 2, maximumFractionDigits: 2 }).format(amount) + '억 원';
            }
        })();
    </script>
</body>
</html>
