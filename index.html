<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>간편 입찰 전략 계산기</title>
    <style>
        :root {
            color-scheme: light;
            --bg-color: #f6f8fc;
            --text-color: #1f2933;
            --subtle-text: #64748b;
            --card-bg: #ffffff;
            --primary: #2563eb;
            --primary-dark: #1d4ed8;
            --border: #e2e8f0;
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: 'Pretendard', 'Segoe UI', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg-color);
            color: var(--text-color);
            line-height: 1.6;
        }

        .app {
            max-width: 760px;
            margin: 0 auto;
            padding: 32px 16px 48px;
        }

        .app-header {
            text-align: center;
            margin-bottom: 28px;
        }

        .app-header h1 {
            font-size: 26px;
            margin: 0 0 10px;
            font-weight: 700;
            color: #0f172a;
        }

        .app-header p {
            margin: 0;
            color: var(--subtle-text);
            font-size: 15px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 24px;
            box-shadow: 0 12px 32px rgba(15, 23, 42, 0.08);
        }

        .input-card {
            margin-bottom: 20px;
        }

        .field {
            display: flex;
            flex-direction: column;
            gap: 6px;
            margin-bottom: 16px;
        }

        .field label {
            font-size: 14px;
            font-weight: 600;
            color: #334155;
        }

        .field input,
        .field textarea {
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 12px 14px;
            font-size: 15px;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
        }

        .field textarea {
            resize: vertical;
            min-height: 96px;
        }

        .field input:focus,
        .field textarea:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.16);
            outline: none;
        }

        .field .field-hint {
            color: var(--subtle-text);
            font-size: 13px;
        }

        .action-row {
            display: flex;
            gap: 12px;
            margin-top: 8px;
        }

        .btn {
            flex: 1;
            border: none;
            border-radius: 12px;
            padding: 13px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.15s ease, box-shadow 0.15s ease, background 0.2s ease;
        }

        .btn-primary {
            background: var(--primary);
            color: #ffffff;
            box-shadow: 0 10px 24px rgba(37, 99, 235, 0.28);
        }

        .btn-primary:hover {
            background: var(--primary-dark);
            transform: translateY(-1px);
        }

        .btn-secondary {
            background: #f1f5f9;
            color: #1f2937;
        }

        .btn-secondary:hover {
            background: #e2e8f0;
        }

        .loading-card {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 16px;
            min-height: 170px;
            text-align: center;
            color: var(--subtle-text);
            font-size: 14px;
        }

        .spinner {
            width: 38px;
            height: 38px;
            border-radius: 50%;
            border: 4px solid #dbeafe;
            border-top-color: var(--primary);
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .result-card {
            display: flex;
            flex-direction: column;
            gap: 24px;
        }

        #resultSummary {
            font-size: 15px;
            color: #1f2937;
            display: grid;
            gap: 8px;
        }

        #resultSummary strong {
            color: #0f172a;
        }

        #resultSummary .hint {
            color: var(--subtle-text);
            font-size: 14px;
        }

        .result-grid {
            display: grid;
            gap: 16px;
            grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
        }

        .result-box {
            background: #f8fafc;
            border-radius: 14px;
            padding: 18px;
            border: 1px solid var(--border);
        }

        .result-box h3 {
            margin: 0 0 10px;
            font-size: 15px;
            color: #1f2937;
        }

        .result-box ul {
            list-style: none;
            padding: 0;
            margin: 0;
            display: grid;
            gap: 8px;
            font-size: 14px;
            color: #4b5563;
        }

        .result-box li strong {
            color: #111827;
        }

        .probability-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
            font-size: 14px;
            color: #475569;
        }

        .probability-row:last-child {
            margin-bottom: 0;
        }

        .probability-label {
            width: 70px;
            font-weight: 600;
            color: #111827;
        }

        .probability-bar {
            position: relative;
            flex: 1;
            height: 8px;
            background: #e2e8f0;
            border-radius: 999px;
            overflow: hidden;
        }

        .probability-fill {
            position: absolute;
            inset: 0;
            width: 0;
            background: linear-gradient(90deg, #2563eb, #3b82f6);
        }

        .probability-value {
            width: 58px;
            text-align: right;
            font-variant-numeric: tabular-nums;
            color: #1f2937;
        }

        .note-card {
            background: #f1f5f9;
            border-radius: 14px;
            padding: 18px;
            border: 1px solid var(--border);
            font-size: 14px;
            color: #475569;
        }

        .note-card h3 {
            margin: 0 0 6px;
            font-size: 15px;
            color: #1f2937;
        }

        .app-footer {
            margin-top: 20px;
            text-align: center;
            font-size: 12px;
            color: #94a3b8;
        }

        [hidden] {
            display: none !important;
        }

        @media (max-width: 640px) {
            .action-row {
                flex-direction: column;
            }

            .btn {
                width: 100%;
            }

            .app {
                padding: 24px 14px 40px;
            }
        }
    </style>
</head>
<body>
    <div class="app">
        <header class="app-header">
            <h1>간편 입찰 전략 계산기</h1>
            <p>핵심 수치만 입력하면 가장 유리한 투찰 구간을 바로 확인할 수 있습니다.</p>
        </header>

        <form id="simulationForm" class="card input-card">
            <div class="field">
                <label for="openPrice">공개가격 (억원)</label>
                <input type="number" id="openPrice" name="openPrice" min="1" step="0.1" value="100">
            </div>
            <div class="field">
                <label for="bidRates">참여업체 투찰률 목록 (%)</label>
                <textarea id="bidRates" name="bidRates" rows="3" placeholder="예: 86.40, 86.70, 87.10, 87.25, 87.40">86.40, 86.70, 87.10, 87.25, 87.40, 87.55, 87.70, 87.85</textarea>
                <small class="field-hint">콤마(,)나 줄바꿈으로 구분해 투찰률을 입력하면 됩니다.</small>
            </div>
            <div class="action-row">
                <button type="submit" class="btn btn-primary">분석 실행</button>
                <button type="button" id="resetButton" class="btn btn-secondary">초기화</button>
            </div>
        </form>

        <div id="loadingIndicator" class="card loading-card" hidden>
            <div class="spinner" aria-hidden="true"></div>
            <p>확률 분포를 계산하는 중입니다...</p>
            <small>잠시만 기다려 주세요.</small>
        </div>

        <section id="resultSection" class="card result-card" hidden aria-live="polite">
            <div id="resultSummary"></div>

            <div class="result-grid">
                <div class="result-box">
                    <h3>핵심 지표</h3>
                    <div id="strategyNotes"></div>
                </div>
                <div class="result-box">
                    <h3>낙찰 확률 상위 구간</h3>
                    <div id="probabilityList"></div>
                </div>
            </div>

            <div class="note-card">
                <h3>시장 해석</h3>
                <p id="marketInsight"></p>
            </div>
        </section>

        <footer class="app-footer">
            ※ 본 계산기는 참고용 이론적 확률 계산 결과를 제공합니다. 실제 투찰 전 추가 검토가 필요합니다.
        </footer>
    </div>

    <script>
        (() => {
            const DEFAULTS = {
                openPrice: 100,
                bidRates: '86.40, 86.70, 87.10, 87.25, 87.40, 87.55, 87.70, 87.85'
            };

            const BASE_RATE = 0.79995;
            const RANGE_RATIO = 0.02;
            const SAMPLE_SIZE = 15;
            const PICK_SIZE = 4;

            const form = document.getElementById('simulationForm');
            const loadingIndicator = document.getElementById('loadingIndicator');
            const resultSection = document.getElementById('resultSection');
            const resultSummary = document.getElementById('resultSummary');
            const strategyNotes = document.getElementById('strategyNotes');
            const probabilityList = document.getElementById('probabilityList');
            const marketInsight = document.getElementById('marketInsight');
            const resetButton = document.getElementById('resetButton');
            const bidRatesInput = document.getElementById('bidRates');

            form.addEventListener('submit', event => {
                event.preventDefault();
                runAnalysis();
            });

            resetButton.addEventListener('click', () => {
                form.reset();
                runAnalysis();
            });

            runAnalysis();

            function runAnalysis() {
                showLoading();

                window.setTimeout(() => {
                    const params = collectFormData();
                    const results = analyzeBids(params);
                    hideLoading();
                    displayResults(params, results);
                }, 30);
            }

            function showLoading() {
                loadingIndicator.hidden = false;
                resultSection.hidden = true;
            }

            function hideLoading() {
                loadingIndicator.hidden = true;
            }

            function collectFormData() {
                const openPrice = sanitizeNumber(document.getElementById('openPrice').value, DEFAULTS.openPrice, 1, 10000);
                const bidRates = parseRateList(bidRatesInput.value, DEFAULTS.bidRates);
                return { openPrice, bidRates };
            }

            function sanitizeNumber(value, fallback, min, max) {
                const parsed = Number.parseFloat(value);
                if (!Number.isFinite(parsed)) {
                    return fallback;
                }
                return Math.min(max, Math.max(min, parsed));
            }

            function parseRateList(raw, fallback) {
                const source = (raw || '').trim();
                const text = source.length ? source : fallback;
                const tokens = text.split(/[\s,]+/);
                const rates = [];
                const seen = new Set();

                for (const token of tokens) {
                    if (!token) continue;
                    const rate = Number.parseFloat(token);
                    if (!Number.isFinite(rate) || rate <= 0) {
                        continue;
                    }
                    const rounded = Math.round(rate * 100) / 100;
                    const key = rounded.toFixed(2);
                    if (!seen.has(key)) {
                        rates.push(rounded);
                        seen.add(key);
                    }
                }

                if (!rates.length && fallback && fallback !== text) {
                    return parseRateList(fallback, '');
                }

                return rates;
            }

            function analyzeBids(params) {
                const basePrice = params.openPrice * BASE_RATE;
                const low = basePrice * (1 - RANGE_RATIO);
                const high = basePrice * (1 + RANGE_RATIO);
                const mean = (low + high) / 2;
                const stdDev = (high - low) / Math.sqrt(48);

                const bids = params.bidRates
                    .map(rate => ({
                        rate,
                        price: params.openPrice * (rate / 100)
                    }))
                    .filter(bid => Number.isFinite(bid.price))
                    .sort((a, b) => a.price - b.price);

                const results = [];
                let prevThreshold = low;

                for (const bid of bids) {
                    const intervalStart = Math.max(prevThreshold, low);
                    const intervalEnd = Math.min(bid.price, high);
                    let probability = 0;
                    if (intervalEnd > intervalStart) {
                        probability = averageCdf(intervalEnd, low, high) - averageCdf(intervalStart, low, high);
                    }
                    results.push({
                        rate: bid.rate,
                        price: bid.price,
                        probability,
                        intervalStart,
                        intervalEnd
                    });
                    prevThreshold = Math.max(prevThreshold, bid.price);
                }

                const leftoverProbability = Math.max(0, 1 - averageCdf(prevThreshold, low, high));

                let bestIndex = results.length ? 0 : -1;
                for (let idx = 1; idx < results.length; idx++) {
                    if (results[idx].probability > results[bestIndex].probability) {
                        bestIndex = idx;
                    }
                }

                const topIndices = results
                    .map((_, idx) => idx)
                    .sort((a, b) => results[b].probability - results[a].probability)
                    .slice(0, Math.min(5, results.length));

                return {
                    basePrice,
                    low,
                    high,
                    mean,
                    stdDev,
                    bids: results,
                    bestIndex,
                    topIndices,
                    leftoverProbability
                };
            }

            function averageCdf(value, low, high) {
                if (value <= low) {
                    return 0;
                }
                if (value >= high) {
                    return 1;
                }
                const scale = high - low;
                const z = (4 * (value - low)) / scale;
                return irwinHallCdf(z);
            }

            function irwinHallCdf(z) {
                if (z <= 0) {
                    return 0;
                }
                if (z >= 4) {
                    return 1;
                }

                const n = 4;
                const upper = Math.floor(z);
                let sum = 0;

                for (let k = 0; k <= upper; k++) {
                    const sign = k % 2 === 0 ? 1 : -1;
                    sum += sign * combination(n, k) * Math.pow(z - k, n);
                }

                return sum / factorial(n);
            }

            function combination(n, k) {
                if (k < 0 || k > n) {
                    return 0;
                }
                if (k === 0 || k === n) {
                    return 1;
                }
                let result = 1;
                for (let i = 1; i <= k; i++) {
                    result *= (n - (k - i));
                    result /= i;
                }
                return result;
            }

            function factorial(n) {
                let result = 1;
                for (let i = 2; i <= n; i++) {
                    result *= i;
                }
                return result;
            }

            function displayResults(params, results) {
                if (!results.bids.length) {
                    resultSummary.innerHTML = `
                        <p>유효한 투찰률을 최소 1개 이상 입력해주세요.</p>
                    `;
                    strategyNotes.innerHTML = '';
                    probabilityList.innerHTML = '';
                    marketInsight.textContent = '투찰률 목록을 입력하면 각 값의 낙찰 확률을 계산해 드립니다.';
                    resultSection.hidden = false;
                    return;
                }

                const bestBid = results.bestIndex >= 0 ? results.bids[results.bestIndex] : null;
                const probabilityPercent = bestBid ? bestBid.probability * 100 : 0;
                const expectedAmount = bestBid ? bestBid.price : 0;

                resultSummary.innerHTML = `
                    <p><strong>${bestBid.rate.toFixed(2)}%</strong> 투찰 시 낙찰 확률은 <strong>${probabilityPercent.toFixed(1)}%</strong>입니다.</p>
                    <p>해당 제시금액은 약 <strong>${formatAmount(expectedAmount)}</strong>입니다.</p>
                    <p class="hint">${buildStrategyHint(probabilityPercent)}</p>
                `;

                const notes = [
                    `기준가격: <strong>${formatAmount(results.basePrice)}</strong>`,
                    `추출 범위 (±2%): <strong>${formatAmount(results.low)} ~ ${formatAmount(results.high)}</strong>`,
                    `표본 평균의 평균값: <strong>${formatAmount(results.mean)}</strong>`,
                    `표본 평균 분포의 표준편차: <strong>${formatAmount(results.stdDev)}</strong>`,
                    `분석 방법: <strong>${SAMPLE_SIZE}개 중 ${PICK_SIZE}개 평균의 정확 분포 계산</strong>`
                ];

                if (results.leftoverProbability > 1e-6) {
                    notes.push(`최고 투찰률보다 a 값이 커 낙찰자가 정해지지 않을 확률: <strong>${(results.leftoverProbability * 100).toFixed(1)}%</strong>`);
                } else {
                    notes.push('입력한 투찰률만으로도 모든 경우 낙찰자가 결정됩니다.');
                }

                strategyNotes.innerHTML = `<ul>${notes.map(note => `<li>${note}</li>`).join('')}</ul>`;

                probabilityList.innerHTML = results.topIndices.map(idx => {
                    const bid = results.bids[idx];
                    const probability = bid.probability * 100;
                    const fillWidth = Math.max(3, Math.min(100, probability));
                    return `
                        <div class="probability-row">
                            <div class="probability-label" title="제시금액 ${formatAmount(bid.price)}">${bid.rate.toFixed(2)}%</div>
                            <div class="probability-bar">
                                <div class="probability-fill" style="width: ${fillWidth}%;"></div>
                            </div>
                            <div class="probability-value">${probability.toFixed(2)}%</div>
                        </div>
                    `;
                }).join('');

                marketInsight.textContent = buildMarketInsight(params, results);

                resultSection.hidden = false;
            }

            function buildStrategyHint(probability) {
                if (probability >= 35) {
                    return '낙찰 가능성이 높은 구간입니다. 다른 조건만 충족된다면 과감한 투찰도 고려할 수 있습니다.';
                }
                if (probability >= 20) {
                    return '낙찰 가능성이 중간 수준입니다. 원가 및 리스크를 면밀히 점검하세요.';
                }
                if (probability > 0) {
                    return '낙찰 확률이 낮은 편이므로 대안 전략을 함께 고민하는 것이 좋습니다.';
                }
                return '해당 투찰률로는 낙찰이 불가능합니다. 상위 가격을 다시 검토하세요.';
            }

            function buildMarketInsight(params, results) {
                if (!results.bids.length) {
                    return '투찰률 목록이 비어 있어 시장 해석을 제공할 수 없습니다.';
                }

                const bestBid = results.bestIndex >= 0 ? results.bids[results.bestIndex] : null;
                if (!bestBid) {
                    return '분석된 투찰률이 없어 해석을 제공할 수 없습니다.';
                }

                const rangeText = `${formatAmount(results.low)} ~ ${formatAmount(results.high)}`;
                let insight = `표본 평균 a 는 ${rangeText} 범위에서 형성되며 평균은 ${formatAmount(results.mean)}입니다. `;

                if (bestBid.probability <= 0) {
                    const highestBid = results.bids[results.bids.length - 1];
                    insight += `모든 투찰률이 a 값 이하에 머물러 낙찰자가 결정되지 않습니다. ${formatAmount(highestBid.price)} 이상의 투찰률을 포함해야 합니다.`;
                    return insight;
                }

                if (results.leftoverProbability > 1e-6) {
                    const highestBid = results.bids[results.bids.length - 1];
                    insight += `a 값이 ${formatAmount(highestBid.price)} 이상이 되는 상황이 ${(results.leftoverProbability * 100).toFixed(1)}% 존재하여 낙찰자가 정해지지 않을 수 있습니다. `;
                } else {
                    const coverage = 1 - results.leftoverProbability;
                    insight += `입력한 투찰률이 분포의 ${(coverage * 100).toFixed(1)}%를 커버하여 모든 경우에 낙찰자가 결정됩니다. `;
                }

                const intervalUpper = Math.min(bestBid.intervalEnd, results.high);
                insight += `가장 유리한 투찰률 ${bestBid.rate.toFixed(2)}%는 a 값이 ${formatAmount(bestBid.intervalStart)} 이상 ${formatAmount(intervalUpper)} 미만일 때 낙찰됩니다.`;

                return insight;
            }

            function formatAmount(amount) {
                return new Intl.NumberFormat('ko-KR', { minimumFractionDigits: 2, maximumFractionDigits: 2 }).format(amount) + '억 원';
            }
        })();
    </script>
</body>
</html>
