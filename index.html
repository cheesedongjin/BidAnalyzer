<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>간편 입찰 전략 계산기</title>
    <style>
        :root {
            color-scheme: light;
            --bg-color: #f6f8fc;
            --text-color: #1f2933;
            --subtle-text: #64748b;
            --card-bg: #ffffff;
            --primary: #2563eb;
            --primary-dark: #1d4ed8;
            --border: #e2e8f0;
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: 'Pretendard', 'Segoe UI', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg-color);
            color: var(--text-color);
            line-height: 1.6;
        }

        .app {
            max-width: 760px;
            margin: 0 auto;
            padding: 32px 16px 48px;
        }

        .app-header {
            text-align: center;
            margin-bottom: 28px;
        }

        .app-header h1 {
            font-size: 26px;
            margin: 0 0 10px;
            font-weight: 700;
            color: #0f172a;
        }

        .app-header p {
            margin: 0;
            color: var(--subtle-text);
            font-size: 15px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 24px;
            box-shadow: 0 12px 32px rgba(15, 23, 42, 0.08);
        }

        .input-card {
            margin-bottom: 20px;
        }

        .field {
            display: flex;
            flex-direction: column;
            gap: 6px;
            margin-bottom: 16px;
        }

        .field label {
            font-size: 14px;
            font-weight: 600;
            color: #334155;
        }

        .field input,
        .field textarea {
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 12px 14px;
            font-size: 15px;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
        }

        .field textarea {
            resize: vertical;
            min-height: 96px;
        }

        .field input:focus,
        .field textarea:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.16);
            outline: none;
        }

        .field .field-hint {
            color: var(--subtle-text);
            font-size: 13px;
        }

        .action-row {
            display: flex;
            gap: 12px;
            margin-top: 8px;
        }

        .btn {
            flex: 1;
            border: none;
            border-radius: 12px;
            padding: 13px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.15s ease, box-shadow 0.15s ease, background 0.2s ease;
        }

        .btn-primary {
            background: var(--primary);
            color: #ffffff;
            box-shadow: 0 10px 24px rgba(37, 99, 235, 0.28);
        }

        .btn-primary:hover {
            background: var(--primary-dark);
            transform: translateY(-1px);
        }

        .btn-secondary {
            background: #f1f5f9;
            color: #1f2937;
        }

        .btn-secondary:hover {
            background: #e2e8f0;
        }

        .loading-card {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 16px;
            min-height: 170px;
            text-align: center;
            color: var(--subtle-text);
            font-size: 14px;
        }

        .spinner {
            width: 38px;
            height: 38px;
            border-radius: 50%;
            border: 4px solid #dbeafe;
            border-top-color: var(--primary);
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .result-card {
            display: flex;
            flex-direction: column;
            gap: 24px;
        }

        #resultSummary {
            font-size: 15px;
            color: #1f2937;
            display: grid;
            gap: 8px;
        }

        #resultSummary strong {
            color: #0f172a;
        }

        #resultSummary .hint {
            color: var(--subtle-text);
            font-size: 14px;
        }

        .result-grid {
            display: grid;
            gap: 16px;
            grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
        }

        .result-box {
            background: #f8fafc;
            border-radius: 14px;
            padding: 18px;
            border: 1px solid var(--border);
        }

        .result-box h3 {
            margin: 0 0 10px;
            font-size: 15px;
            color: #1f2937;
        }

        .result-box ul {
            list-style: none;
            padding: 0;
            margin: 0;
            display: grid;
            gap: 8px;
            font-size: 14px;
            color: #4b5563;
        }

        .result-box li strong {
            color: #111827;
        }

        .probability-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
            font-size: 14px;
            color: #475569;
        }

        .probability-row:last-child {
            margin-bottom: 0;
        }

        .probability-label {
            width: 70px;
            font-weight: 600;
            color: #111827;
        }

        .probability-bar {
            position: relative;
            flex: 1;
            height: 8px;
            background: #e2e8f0;
            border-radius: 999px;
            overflow: hidden;
        }

        .probability-fill {
            position: absolute;
            inset: 0;
            width: 0;
            background: linear-gradient(90deg, #2563eb, #3b82f6);
        }

        .probability-value {
            width: 58px;
            text-align: right;
            font-variant-numeric: tabular-nums;
            color: #1f2937;
        }

        .note-card {
            background: #f1f5f9;
            border-radius: 14px;
            padding: 18px;
            border: 1px solid var(--border);
            font-size: 14px;
            color: #475569;
        }

        .note-card h3 {
            margin: 0 0 6px;
            font-size: 15px;
            color: #1f2937;
        }

        .app-footer {
            margin-top: 20px;
            text-align: center;
            font-size: 12px;
            color: #94a3b8;
        }

        [hidden] {
            display: none !important;
        }

        @media (max-width: 640px) {
            .action-row {
                flex-direction: column;
            }

            .btn {
                width: 100%;
            }

            .app {
                padding: 24px 14px 40px;
            }
        }
    </style>
</head>
<body>
    <div class="app">
        <header class="app-header">
            <h1>간편 입찰 전략 계산기</h1>
            <p>핵심 수치만 입력하면 가장 유리한 투찰 구간을 바로 확인할 수 있습니다.</p>
        </header>

        <form id="simulationForm" class="card input-card">
            <div class="field">
                <label for="openPrice">공개가격 (억원)</label>
                <input type="number" id="openPrice" name="openPrice" min="1" step="0.1" value="100">
            </div>
            <div class="field">
                <label for="bidRates">참여업체 투찰률 목록 (%)</label>
                <textarea id="bidRates" name="bidRates" rows="3" placeholder="예: 86.40, 86.70, 87.10, 87.25, 87.40">86.40, 86.70, 87.10, 87.25, 87.40, 87.55, 87.70, 87.85</textarea>
                <small class="field-hint">콤마(,)나 줄바꿈으로 구분해 투찰률을 입력하면 됩니다.</small>
            </div>
            <div class="action-row">
                <button type="submit" class="btn btn-primary">분석 실행</button>
                <button type="button" id="resetButton" class="btn btn-secondary">초기화</button>
            </div>
        </form>

        <div id="loadingIndicator" class="card loading-card" hidden>
            <div class="spinner" aria-hidden="true"></div>
            <p>확률 분포를 계산하는 중입니다...</p>
            <small>잠시만 기다려 주세요.</small>
        </div>

        <section id="resultSection" class="card result-card" hidden aria-live="polite">
            <div id="resultSummary"></div>

            <div class="result-grid">
                <div class="result-box">
                    <h3>핵심 지표</h3>
                    <div id="strategyNotes"></div>
                </div>
                <div class="result-box">
                    <h3>낙찰 확률 상위 구간</h3>
                    <div id="probabilityList"></div>
                </div>
            </div>

            <div class="note-card">
                <h3>시장 해석</h3>
                <p id="marketInsight"></p>
            </div>
        </section>

        <footer class="app-footer">
            ※ 본 계산기는 참고용 이론적 확률 계산 결과를 제공합니다. 실제 투찰 전 추가 검토가 필요합니다.
        </footer>
    </div>

    <script>
        (() => {
            const DEFAULTS = {
                openPrice: 100,
                bidRates: '86.40, 86.70, 87.10, 87.25, 87.40, 87.55, 87.70, 87.85'
            };

            const BASE_RATE = 0.79995;
            const RANGE_RATIO = 0.02;
            const SAMPLE_SIZE = 15;
            const PICK_SIZE = 4;

            const form = document.getElementById('simulationForm');
            const loadingIndicator = document.getElementById('loadingIndicator');
            const resultSection = document.getElementById('resultSection');
            const resultSummary = document.getElementById('resultSummary');
            const strategyNotes = document.getElementById('strategyNotes');
            const probabilityList = document.getElementById('probabilityList');
            const marketInsight = document.getElementById('marketInsight');
            const resetButton = document.getElementById('resetButton');
            const bidRatesInput = document.getElementById('bidRates');

            form.addEventListener('submit', event => {
                event.preventDefault();
                runAnalysis();
            });

            resetButton.addEventListener('click', () => {
                form.reset();
                runAnalysis();
            });

            runAnalysis();

            function runAnalysis() {
                showLoading();

                window.setTimeout(() => {
                    const params = collectFormData();
                    const results = analyzeBids(params);
                    hideLoading();
                    displayResults(params, results);
                }, 30);
            }

            function showLoading() {
                loadingIndicator.hidden = false;
                resultSection.hidden = true;
            }

            function hideLoading() {
                loadingIndicator.hidden = true;
            }

            function collectFormData() {
                const openPrice = sanitizeNumber(document.getElementById('openPrice').value, DEFAULTS.openPrice, 1, 10000);
                const bidRates = parseRateList(bidRatesInput.value, DEFAULTS.bidRates);
                return { openPrice, bidRates };
            }

            function sanitizeNumber(value, fallback, min, max) {
                const parsed = Number.parseFloat(value);
                if (!Number.isFinite(parsed)) {
                    return fallback;
                }
                return Math.min(max, Math.max(min, parsed));
            }

            function parseRateList(raw, fallback) {
                const source = (raw || '').trim();
                const text = source.length ? source : fallback;
                const tokens = text.split(/[\s,]+/);
                const rates = [];
                const seen = new Set();

                for (const token of tokens) {
                    if (!token) continue;
                    const rate = Number.parseFloat(token);
                    if (!Number.isFinite(rate) || rate <= 0) {
                        continue;
                    }
                    const rounded = Math.round(rate * 100) / 100;
                    const key = rounded.toFixed(2);
                    if (!seen.has(key)) {
                        rates.push(rounded);
                        seen.add(key);
                    }
                }

                if (!rates.length && fallback && fallback !== text) {
                    return parseRateList(fallback, '');
                }

                return rates;
            }

            function analyzeBids(params) {
                const basePrice = params.openPrice * BASE_RATE;
                const low = basePrice * (1 - RANGE_RATIO);
                const high = basePrice * (1 + RANGE_RATIO);
                const mean = (low + high) / 2;
                const stdDev = (high - low) / Math.sqrt(12 * PICK_SIZE);

                const bids = params.bidRates
                    .map(rate => ({
                        rate,
                        price: params.openPrice * (rate / 100)
                    }))
                    .filter(bid => Number.isFinite(bid.price))
                    .sort((a, b) => a.price - b.price);

                if (!bids.length) {
                    return {
                        basePrice,
                        low,
                        high,
                        mean,
                        stdDev,
                        bids: [],
                        bestIndex: -1,
                        topIndices: [],
                        leftoverProbability: 1,
                        otherCompanyCount: 0,
                        distribution: null,
                        maxPrice: low
                    };
                }

                const priceData = bids.map(bid => clamp(bid.price, low, high));
                const distribution = buildCompetitorDistribution(priceData, low, high, params.openPrice);
                const otherCompanyCount = Math.max(0, bids.length - 1);

                const integrationGrid = createIntegrationGrid(low, high, 4096);
                const averagePdfValues = integrationGrid.map(value => averagePdf(value, low, high, PICK_SIZE));
                const distributionCdfValues = integrationGrid.map(value => distribution.cdf(value));

                const results = [];
                let bestIndex = -1;
                let maxProbability = -1;

                for (let idx = 0; idx < bids.length; idx++) {
                    const bid = bids[idx];
                    const probability = computeWinProbability(
                        bid.price,
                        low,
                        high,
                        otherCompanyCount,
                        distribution,
                        integrationGrid,
                        averagePdfValues,
                        distributionCdfValues,
                        PICK_SIZE
                    );
                    const thresholdUpper = Math.min(bid.price, high);
                    const thresholdShare = averageCdf(thresholdUpper, low, high, PICK_SIZE);
                    const competitorShareBelow = clamp01(distribution.cdf(bid.price));

                    const entry = {
                        rate: bid.rate,
                        price: bid.price,
                        probability,
                        thresholdUpper,
                        thresholdShare,
                        competitorShareBelow
                    };

                    results.push(entry);

                    if (probability > maxProbability) {
                        maxProbability = probability;
                        bestIndex = idx;
                    }
                }

                const maxPrice = results.reduce((acc, item) => Math.max(acc, item.price), low);
                const coverage = averageCdf(Math.min(maxPrice, high), low, high, PICK_SIZE);
                const leftoverProbability = Math.max(0, 1 - coverage);

                const topIndices = results
                    .map((_, idx) => idx)
                    .sort((a, b) => results[b].probability - results[a].probability)
                    .slice(0, Math.min(5, results.length));

                return {
                    basePrice,
                    low,
                    high,
                    mean,
                    stdDev,
                    bids: results,
                    bestIndex,
                    topIndices,
                    leftoverProbability,
                    otherCompanyCount,
                    distribution,
                    maxPrice
                };
            }

            function createIntegrationGrid(low, high, steps = 4096) {
                const pointCount = Math.max(2, Math.trunc(steps));
                const result = new Array(pointCount);
                const step = (high - low) / (pointCount - 1);
                for (let idx = 0; idx < pointCount; idx++) {
                    result[idx] = low + step * idx;
                }
                return result;
            }

            function computeWinProbability(price, low, high, otherCompanyCount, distribution, grid, averagePdfValues, distributionCdfValues, pickSize) {
                if (price <= low) {
                    return 0;
                }

                const upper = Math.min(price, high);
                if (upper <= low) {
                    return 0;
                }

                const gp = clamp01(distribution.cdf(price));
                const exponent = otherCompanyCount;

                const integrand = (pdfValue, cdfValue) => {
                    if (pdfValue <= 0) {
                        return 0;
                    }
                    const base = clamp01(cdfValue + 1 - gp);
                    if (base <= 0) {
                        return 0;
                    }
                    return pdfValue * Math.pow(base, exponent);
                };

                let integral = 0;
                let previousA = grid[0];
                let previousIntegrand = integrand(averagePdfValues[0], distributionCdfValues[0]);

                for (let idx = 1; idx < grid.length; idx++) {
                    const currentA = grid[idx];
                    const currentIntegrand = integrand(averagePdfValues[idx], distributionCdfValues[idx]);

                    if (currentA >= upper) {
                        const finalPdf = averagePdf(upper, low, high, pickSize);
                        const finalCdf = distribution.cdf(upper);
                        const finalIntegrand = integrand(finalPdf, finalCdf);
                        integral += 0.5 * (upper - previousA) * (previousIntegrand + finalIntegrand);
                        previousA = upper;
                        previousIntegrand = finalIntegrand;
                        break;
                    } else {
                        integral += 0.5 * (currentA - previousA) * (previousIntegrand + currentIntegrand);
                        previousA = currentA;
                        previousIntegrand = currentIntegrand;
                    }
                }

                if (previousA < upper) {
                    const finalPdf = averagePdf(upper, low, high, pickSize);
                    const finalCdf = distribution.cdf(upper);
                    const finalIntegrand = integrand(finalPdf, finalCdf);
                    integral += 0.5 * (upper - previousA) * (previousIntegrand + finalIntegrand);
                }

                return clamp01(integral);
            }

            function averageCdf(value, low, high, pickSize) {
                if (value <= low) {
                    return 0;
                }
                if (value >= high) {
                    return 1;
                }
                const scale = high - low;
                const z = (pickSize * (value - low)) / scale;
                return irwinHallCdf(z, pickSize);
            }

            function averagePdf(value, low, high, pickSize) {
                if (value <= low || value >= high) {
                    return 0;
                }
                const scale = high - low;
                const z = (pickSize * (value - low)) / scale;
                return (pickSize / scale) * irwinHallPdf(z, pickSize);
            }

            function irwinHallCdf(z, n) {
                if (z <= 0) {
                    return 0;
                }
                if (z >= n) {
                    return 1;
                }

                const upper = Math.floor(z);
                let sum = 0;

                for (let k = 0; k <= upper; k++) {
                    const sign = k % 2 === 0 ? 1 : -1;
                    sum += sign * combination(n, k) * Math.pow(z - k, n);
                }

                return sum / factorial(n);
            }

            function irwinHallPdf(z, n) {
                if (z <= 0 || z >= n) {
                    return 0;
                }

                const upper = Math.floor(z);
                let sum = 0;

                for (let k = 0; k <= upper; k++) {
                    const sign = k % 2 === 0 ? 1 : -1;
                    sum += sign * combination(n, k) * Math.pow(z - k, n - 1);
                }

                return sum / factorial(n - 1);
            }

            function combination(n, k) {
                if (k < 0 || k > n) {
                    return 0;
                }
                if (k === 0 || k === n) {
                    return 1;
                }
                let result = 1;
                for (let i = 1; i <= k; i++) {
                    result *= (n - (k - i));
                    result /= i;
                }
                return result;
            }

            function factorial(n) {
                let result = 1;
                for (let i = 2; i <= n; i++) {
                    result *= i;
                }
                return result;
            }

            function buildCompetitorDistribution(prices, low, high, openPrice) {
                const range = Math.max(high - low, 1e-9);
                const count = prices.length;

                if (!count) {
                    const uniform = createUniformDistribution(low, high);
                    const mu = uniform.mu;
                    const sigma = uniform.sigma;
                    return {
                        ...uniform,
                        mu,
                        sigma,
                        sampleMean: mu,
                        sampleStd: sigma,
                        rateSampleMean: (mu / openPrice) * 100,
                        rateSampleStd: (sigma / openPrice) * 100,
                        rateMu: (mu / openPrice) * 100,
                        rateSigma: (sigma / openPrice) * 100,
                        count: 0
                    };
                }

                const sampleMean = prices.reduce((acc, value) => acc + value, 0) / count;
                const sampleVariance = count > 1
                    ? prices.reduce((acc, value) => acc + Math.pow(value - sampleMean, 2), 0) / (count - 1)
                    : 0;
                const sampleStd = Math.sqrt(Math.max(sampleVariance, 0));

                const muTarget = clamp(sampleMean, low + 0.05 * range, high - 0.05 * range);
                const sigmaTarget = Math.max(sampleStd, range / 20);

                let baseDistribution;
                if (count >= 3) {
                    baseDistribution = buildTruncatedNormalDistribution(low, high, muTarget, sigmaTarget);
                } else {
                    baseDistribution = createUniformDistribution(low, high);
                }

                const mu = baseDistribution.mu ?? muTarget;
                const sigma = baseDistribution.sigma ?? Math.max(sampleStd, range / Math.sqrt(12));

                return {
                    ...baseDistribution,
                    mu,
                    sigma,
                    sampleMean,
                    sampleStd,
                    rateSampleMean: (sampleMean / openPrice) * 100,
                    rateSampleStd: (sampleStd / openPrice) * 100,
                    rateMu: (mu / openPrice) * 100,
                    rateSigma: (sigma / openPrice) * 100,
                    count
                };
            }

            function buildTruncatedNormalDistribution(low, high, mu, sigma) {
                const range = high - low;
                let adjustedMu = clamp(mu, low + 0.01 * range, high - 0.01 * range);
                let adjustedSigma = Math.max(sigma, range / 40, 1e-6 * Math.abs(mu));
                let alpha;
                let beta;
                let denom;

                for (let attempt = 0; attempt < 6; attempt++) {
                    alpha = (low - adjustedMu) / adjustedSigma;
                    beta = (high - adjustedMu) / adjustedSigma;
                    denom = standardNormalCdf(beta) - standardNormalCdf(alpha);
                    if (denom > 1e-8) {
                        break;
                    }
                    adjustedSigma *= 1.5;
                }

                if (!Number.isFinite(denom) || denom <= 1e-8) {
                    return createUniformDistribution(low, high);
                }

                return {
                    type: '절단 정규',
                    mu: adjustedMu,
                    sigma: adjustedSigma,
                    pdf(value) {
                        if (value < low || value > high) {
                            return 0;
                        }
                        const z = (value - adjustedMu) / adjustedSigma;
                        return standardNormalPdf(z) / (adjustedSigma * denom);
                    },
                    cdf(value) {
                        if (value <= low) {
                            return 0;
                        }
                        if (value >= high) {
                            return 1;
                        }
                        const z = (value - adjustedMu) / adjustedSigma;
                        const numerator = standardNormalCdf(z) - standardNormalCdf(alpha);
                        return clamp01(numerator / denom);
                    }
                };
            }

            function createUniformDistribution(low, high) {
                const range = Math.max(high - low, 1e-9);
                const mu = (low + high) / 2;
                const sigma = range / Math.sqrt(12);
                return {
                    type: '균등',
                    mu,
                    sigma,
                    pdf(value) {
                        if (value < low || value > high) {
                            return 0;
                        }
                        return 1 / range;
                    },
                    cdf(value) {
                        if (value <= low) {
                            return 0;
                        }
                        if (value >= high) {
                            return 1;
                        }
                        return (value - low) / range;
                    }
                };
            }

            function standardNormalPdf(x) {
                return Math.exp(-0.5 * x * x) / Math.sqrt(2 * Math.PI);
            }

            function standardNormalCdf(x) {
                return 0.5 * (1 + erf(x / Math.SQRT2));
            }

            function erf(x) {
                const sign = x >= 0 ? 1 : -1;
                const absX = Math.abs(x);
                const t = 1 / (1 + 0.3275911 * absX);
                const a1 = 0.254829592;
                const a2 = -0.284496736;
                const a3 = 1.421413741;
                const a4 = -1.453152027;
                const a5 = 1.061405429;
                const poly = (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t;
                const expTerm = Math.exp(-absX * absX);
                return sign * (1 - poly * expTerm);
            }

            function clamp(value, min, max) {
                return Math.min(max, Math.max(min, value));
            }

            function clamp01(value) {
                return clamp(value, 0, 1);
            }

            function displayResults(params, results) {
                if (!results.bids.length) {
                    resultSummary.innerHTML = `
                        <p>유효한 투찰률을 최소 1개 이상 입력해주세요.</p>
                    `;
                    strategyNotes.innerHTML = '';
                    probabilityList.innerHTML = '';
                    marketInsight.textContent = '투찰률 목록을 입력하면 각 값의 낙찰 확률을 계산해 드립니다.';
                    resultSection.hidden = false;
                    return;
                }

                const bestBid = results.bestIndex >= 0 ? results.bids[results.bestIndex] : null;
                const probabilityPercent = bestBid ? bestBid.probability * 100 : 0;
                const expectedAmount = bestBid ? bestBid.price : 0;

                resultSummary.innerHTML = `
                    <p><strong>${bestBid.rate.toFixed(2)}%</strong> 투찰 시 낙찰 확률은 <strong>${probabilityPercent.toFixed(1)}%</strong>입니다.</p>
                    <p>해당 제시금액은 약 <strong>${formatAmount(expectedAmount)}</strong>입니다.</p>
                    <p class="hint">${buildStrategyHint(probabilityPercent)}</p>
                `;

                const rangePercent = (RANGE_RATIO * 100).toFixed(2);
                const notes = [
                    `기준가격: <strong>${formatAmount(results.basePrice)}</strong>`,
                    `추출 범위 (±${rangePercent}%): <strong>${formatAmount(results.low)} ~ ${formatAmount(results.high)}</strong>`,
                    `표본 평균의 평균값: <strong>${formatAmount(results.mean)}</strong>`,
                    `표본 평균 분포의 표준편차: <strong>${formatAmount(results.stdDev)}</strong>`,
                    `타 업체 수 가정: <strong>${results.otherCompanyCount}</strong>곳`
                ];

                if (results.distribution) {
                    const dist = results.distribution;
                    notes.push(`타 업체 분포: <strong>${dist.type}</strong> (평균 ${formatAmount(dist.mu)}, 표준편차 ${formatAmount(dist.sigma)})`);
                    notes.push(`입력 데이터 ${dist.count}건 기준 평균/표준편차: <strong>${formatAmount(dist.sampleMean)}</strong> / <strong>${formatAmount(dist.sampleStd)}</strong> (투찰률 ${dist.rateSampleMean.toFixed(2)}% / ${dist.rateSampleStd.toFixed(2)}%)`);
                }

                notes.push(`분석 방법: <strong>${SAMPLE_SIZE}개 중 ${PICK_SIZE}개 평균분포 + 타업체 연속분포 적분</strong>`);

                if (results.leftoverProbability > 1e-6) {
                    notes.push(`임계값이 최고 투찰금액을 초과해 낙찰자가 정해지지 않을 확률: <strong>${(results.leftoverProbability * 100).toFixed(1)}%</strong>`);
                } else {
                    notes.push('입력한 투찰률만으로도 모든 경우 낙찰자가 결정됩니다.');
                }

                strategyNotes.innerHTML = `<ul>${notes.map(note => `<li>${note}</li>`).join('')}</ul>`;

                probabilityList.innerHTML = results.topIndices.map(idx => {
                    const bid = results.bids[idx];
                    const probability = bid.probability * 100;
                    const fillWidth = Math.max(3, Math.min(100, probability));
                    const tooltip = [
                        `제시금액 ${formatAmount(bid.price)}`,
                        `임계값 커버 ${(bid.thresholdShare * 100).toFixed(1)}%`,
                        `타 업체 ≤ ${bid.rate.toFixed(2)}% 비중 ${(bid.competitorShareBelow * 100).toFixed(1)}%`
                    ].join(' | ');
                    return `
                        <div class="probability-row">
                            <div class="probability-label" title="${tooltip}">${bid.rate.toFixed(2)}%</div>
                            <div class="probability-bar">
                                <div class="probability-fill" style="width: ${fillWidth}%;"></div>
                            </div>
                            <div class="probability-value">${probability.toFixed(2)}%</div>
                        </div>
                    `;
                }).join('');

                marketInsight.textContent = buildMarketInsight(params, results);

                resultSection.hidden = false;
            }

            function buildStrategyHint(probability) {
                if (probability >= 35) {
                    return '낙찰 가능성이 높은 구간입니다. 다른 조건만 충족된다면 과감한 투찰도 고려할 수 있습니다.';
                }
                if (probability >= 20) {
                    return '낙찰 가능성이 중간 수준입니다. 원가 및 리스크를 면밀히 점검하세요.';
                }
                if (probability > 0) {
                    return '낙찰 확률이 낮은 편이므로 대안 전략을 함께 고민하는 것이 좋습니다.';
                }
                return '해당 투찰률로는 낙찰이 불가능합니다. 상위 가격을 다시 검토하세요.';
            }

            function buildMarketInsight(params, results) {
                if (!results.bids.length) {
                    return '투찰률 목록이 비어 있어 시장 해석을 제공할 수 없습니다.';
                }

                const bestBid = results.bestIndex >= 0 ? results.bids[results.bestIndex] : null;
                if (!bestBid) {
                    return '분석된 투찰률이 없어 해석을 제공할 수 없습니다.';
                }

                const rangeText = `${formatAmount(results.low)} ~ ${formatAmount(results.high)}`;
                let insight = `임계값 A는 ${rangeText} 범위에서 형성되며 평균은 ${formatAmount(results.mean)}입니다. `;

                if (results.distribution) {
                    const dist = results.distribution;
                    insight += `타 업체 제시가격 분포는 ${dist.type}으로 가정했으며 평균 투찰률은 ${dist.rateMu.toFixed(2)}%, 표준편차는 ${dist.rateSigma.toFixed(2)}% 수준입니다. `;
                }

                if (bestBid.probability <= 0) {
                    const highestBid = results.bids[results.bids.length - 1];
                    const cap = Math.min(results.high, highestBid.price);
                    insight += `현재 입력한 후보만으로는 임계값을 넘는 전략이 없어 낙찰이 어렵습니다. ${formatAmount(cap)} 이상의 금액도 검토하세요.`;
                    return insight;
                }

                insight += `${bestBid.rate.toFixed(2)}% (${formatAmount(bestBid.price)}) 투찰 시 낙찰 확률은 ${(bestBid.probability * 100).toFixed(1)}%입니다. `;
                insight += `임계값이 ${formatAmount(bestBid.thresholdUpper)} 이하로 형성되는 경우는 전체의 ${(bestBid.thresholdShare * 100).toFixed(1)}%이며, 이 구간에서 타 업체 누적 비중은 ${(bestBid.competitorShareBelow * 100).toFixed(1)}%로 추정됩니다. `;

                if (results.leftoverProbability > 1e-6) {
                    const cap = Math.min(results.high, results.maxPrice);
                    insight += `또한 임계값이 ${formatAmount(cap)} 이상일 경우 낙찰자가 정해지지 않을 확률이 ${(results.leftoverProbability * 100).toFixed(1)}% 존재합니다.`;
                } else {
                    const coverage = 1 - results.leftoverProbability;
                    insight += `입력한 투찰률 구간만으로도 ${(coverage * 100).toFixed(1)}%의 상황에서 낙찰자가 결정됩니다.`;
                }

                return insight;
            }

            function formatAmount(amount) {
                return new Intl.NumberFormat('ko-KR', { minimumFractionDigits: 2, maximumFractionDigits: 2 }).format(amount) + '억 원';
            }
        })();
    </script>
</body>
</html>
